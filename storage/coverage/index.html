
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/jianfengye/hade/framework/container.go (78.3%)</option>
				
				<option value="file1">github.com/jianfengye/hade/framework/provider/app/provider.go (100.0%)</option>
				
				<option value="file2">github.com/jianfengye/hade/framework/provider/app/service.go (70.0%)</option>
				
				<option value="file3">github.com/jianfengye/hade/framework/provider/config/fake_provider.go (0.0%)</option>
				
				<option value="file4">github.com/jianfengye/hade/framework/provider/config/fake_service.go (0.0%)</option>
				
				<option value="file5">github.com/jianfengye/hade/framework/provider/config/provider.go (100.0%)</option>
				
				<option value="file6">github.com/jianfengye/hade/framework/provider/config/service.go (75.4%)</option>
				
				<option value="file7">github.com/jianfengye/hade/framework/provider/env/provider.go (100.0%)</option>
				
				<option value="file8">github.com/jianfengye/hade/framework/provider/env/service.go (75.0%)</option>
				
				<option value="file9">github.com/jianfengye/hade/framework/provider/gorm/provider.go (88.9%)</option>
				
				<option value="file10">github.com/jianfengye/hade/framework/provider/gorm/service.go (75.0%)</option>
				
				<option value="file11">github.com/jianfengye/hade/framework/provider/log/provider.go (57.1%)</option>
				
				<option value="file12">github.com/jianfengye/hade/framework/services.go (0.0%)</option>
				
				<option value="file13">github.com/jianfengye/hade/gin/auth.go (100.0%)</option>
				
				<option value="file14">github.com/jianfengye/hade/gin/binding/binding.go (100.0%)</option>
				
				<option value="file15">github.com/jianfengye/hade/gin/binding/default_validator.go (100.0%)</option>
				
				<option value="file16">github.com/jianfengye/hade/gin/binding/form.go (100.0%)</option>
				
				<option value="file17">github.com/jianfengye/hade/gin/binding/form_mapping.go (100.0%)</option>
				
				<option value="file18">github.com/jianfengye/hade/gin/binding/json.go (100.0%)</option>
				
				<option value="file19">github.com/jianfengye/hade/gin/binding/msgpack.go (100.0%)</option>
				
				<option value="file20">github.com/jianfengye/hade/gin/binding/protobuf.go (100.0%)</option>
				
				<option value="file21">github.com/jianfengye/hade/gin/binding/query.go (100.0%)</option>
				
				<option value="file22">github.com/jianfengye/hade/gin/binding/uri.go (100.0%)</option>
				
				<option value="file23">github.com/jianfengye/hade/gin/binding/xml.go (100.0%)</option>
				
				<option value="file24">github.com/jianfengye/hade/gin/binding/yaml.go (100.0%)</option>
				
				<option value="file25">github.com/jianfengye/hade/gin/context.go (98.3%)</option>
				
				<option value="file26">github.com/jianfengye/hade/gin/debug.go (93.3%)</option>
				
				<option value="file27">github.com/jianfengye/hade/gin/deprecated.go (100.0%)</option>
				
				<option value="file28">github.com/jianfengye/hade/gin/errors.go (100.0%)</option>
				
				<option value="file29">github.com/jianfengye/hade/gin/fs.go (100.0%)</option>
				
				<option value="file30">github.com/jianfengye/hade/gin/gin.go (99.4%)</option>
				
				<option value="file31">github.com/jianfengye/hade/gin/hade.go (0.0%)</option>
				
				<option value="file32">github.com/jianfengye/hade/gin/logger.go (100.0%)</option>
				
				<option value="file33">github.com/jianfengye/hade/gin/mode.go (92.3%)</option>
				
				<option value="file34">github.com/jianfengye/hade/gin/path.go (100.0%)</option>
				
				<option value="file35">github.com/jianfengye/hade/gin/recovery.go (98.4%)</option>
				
				<option value="file36">github.com/jianfengye/hade/gin/render/data.go (100.0%)</option>
				
				<option value="file37">github.com/jianfengye/hade/gin/render/html.go (100.0%)</option>
				
				<option value="file38">github.com/jianfengye/hade/gin/render/json.go (92.6%)</option>
				
				<option value="file39">github.com/jianfengye/hade/gin/render/msgpack.go (100.0%)</option>
				
				<option value="file40">github.com/jianfengye/hade/gin/render/protobuf.go (100.0%)</option>
				
				<option value="file41">github.com/jianfengye/hade/gin/render/reader.go (100.0%)</option>
				
				<option value="file42">github.com/jianfengye/hade/gin/render/redirect.go (100.0%)</option>
				
				<option value="file43">github.com/jianfengye/hade/gin/render/render.go (100.0%)</option>
				
				<option value="file44">github.com/jianfengye/hade/gin/render/text.go (100.0%)</option>
				
				<option value="file45">github.com/jianfengye/hade/gin/render/xml.go (100.0%)</option>
				
				<option value="file46">github.com/jianfengye/hade/gin/render/yaml.go (100.0%)</option>
				
				<option value="file47">github.com/jianfengye/hade/gin/response_writer.go (96.7%)</option>
				
				<option value="file48">github.com/jianfengye/hade/gin/routergroup.go (100.0%)</option>
				
				<option value="file49">github.com/jianfengye/hade/gin/test_helpers.go (100.0%)</option>
				
				<option value="file50">github.com/jianfengye/hade/gin/tree.go (100.0%)</option>
				
				<option value="file51">github.com/jianfengye/hade/gin/utils.go (94.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package framework

import (
        "sync"

        "github.com/pkg/errors"
)

// Container is a core struct which store provider and instance
type Container interface {
        // Bind bind a service provider
        Bind(provider ServiceProvider, isSingleton bool) error
        // Singlton is Bind a singlton service provider
        Singleton(provider ServiceProvider) error
        // IsBind check a service provider has been bind
        IsBind(key string) bool

        // Make to get a service provider
        Make(key string) (interface{}, error)
        // MustMake to get a service provider which will not return error
        // if errorï¼Œpanic it
        // If you use it, make sure it will not panic, or you can cover it
        MustMake(key string) interface{}
        // MakeNew to new a service
        // The service Must not be singlton, it with params to make a new service
        MakeNew(key string, params []interface{}) (interface{}, error)
}

// HadeContainer is instance of Container
type HadeContainer struct {
        Container
        providers    []ServiceProvider
        instances    map[string]interface{}
        methods      map[string]NewInstance
        isSingletons map[string]bool

        lock sync.RWMutex
}

// NewHadeContainer is new instance
func NewHadeContainer() *HadeContainer <span class="cov8" title="1">{
        return &amp;HadeContainer{
                providers:    []ServiceProvider{},
                instances:    map[string]interface{}{},
                methods:      map[string]NewInstance{},
                isSingletons: map[string]bool{},
                lock:         sync.RWMutex{},
        }
}</span>

// Bind make relationship between provider and contract
func (hade *HadeContainer) Bind(provider ServiceProvider, isSingleton bool) error <span class="cov8" title="1">{
        hade.lock.RLock()
        defer hade.lock.RUnlock()
        key := provider.Name()

        hade.providers = append(hade.providers, provider)
        hade.isSingletons[key] = isSingleton
        hade.methods[key] = provider.Register(hade)

        // if provider is not defer
        if provider.IsDefer() == false </span><span class="cov8" title="1">{
                provider.Boot(hade)
                params := provider.Params()
                method := hade.methods[key]
                instance, err := method(params...)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.New(err.Error())
                }</span>
                <span class="cov8" title="1">if isSingleton == true </span><span class="cov8" title="1">{
                        hade.instances[key] = instance
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Singleton make provider be Singleton, instance once
func (hade *HadeContainer) Singleton(provider ServiceProvider) error <span class="cov8" title="1">{
        return hade.Bind(provider, true)
}</span>

func (hade *HadeContainer) IsBind(key string) bool <span class="cov0" title="0">{
        return hade.findServiceProvider(key) != nil
}</span>

func (hade *HadeContainer) findServiceProvider(key string) ServiceProvider <span class="cov8" title="1">{
        for _, sp := range hade.providers </span><span class="cov8" title="1">{
                if sp.Name() == key </span><span class="cov8" title="1">{
                        return sp
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (hade *HadeContainer) Make(key string) (interface{}, error) <span class="cov8" title="1">{
        return hade.make(key, nil)
}</span>

func (hade *HadeContainer) MustMake(key string) interface{} <span class="cov0" title="0">{
        serv, err := hade.make(key, nil)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return serv</span>
}

func (hade *HadeContainer) MakeNew(key string, params []interface{}) (interface{}, error) <span class="cov0" title="0">{
        return hade.make(key, params)
}</span>

func (hade *HadeContainer) make(key string, params []interface{}) (interface{}, error) <span class="cov8" title="1">{
        // check has Register
        if hade.findServiceProvider(key) == nil </span><span class="cov0" title="0">{
                return nil, errors.New("contract " + key + " have not register")
        }</span>

        // check instance
        <span class="cov8" title="1">if ins, ok := hade.instances[key]; ok </span><span class="cov8" title="1">{
                return ins, nil
        }</span>

        // is not instance
        <span class="cov8" title="1">method := hade.methods[key] // must ok
        prov := hade.findServiceProvider(key)
        isSingle := hade.isSingletons[key]
        prov.Boot(hade)
        if params == nil </span><span class="cov8" title="1">{
                params = prov.Params()
        }</span>
        <span class="cov8" title="1">ins, err := method(params...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New(err.Error())
        }</span>

        <span class="cov8" title="1">if isSingle </span><span class="cov8" title="1">{
                hade.instances[key] = ins
                return ins, nil
        }</span>
        <span class="cov8" title="1">return ins, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package app

import (
        "github.com/jianfengye/hade/framework"
        "github.com/jianfengye/hade/framework/contract"
)

// HadeAppProvider provide a App service, it must be singlton, and not delay
type HadeAppProvider struct {
        app *HadeApp

        BasePath string
}

// Register registe a new function for make a service instance
func (provider *HadeAppProvider) Register(c framework.Container) framework.NewInstance <span class="cov8" title="1">{
        return NewHadeApp
}</span>

// Boot will called when the service instantiate
func (provider *HadeAppProvider) Boot(c framework.Container) {<span class="cov8" title="1">
}</span>

// IsDefer define whether the service instantiate when first make or register
func (provider *HadeAppProvider) IsDefer() bool <span class="cov8" title="1">{
        return false
}</span>

// Params define the necessary params for NewInstance
func (provider *HadeAppProvider) Params() []interface{} <span class="cov8" title="1">{
        return []interface{}{provider.BasePath}
}</span>

/// Name define the name for this service
func (provider *HadeAppProvider) Name() string <span class="cov8" title="1">{
        return contract.AppKey
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package app

type HadeApp struct{
        basePath string
}

func NewHadeApp(params ...interface{}) (interface{}, error) <span class="cov8" title="1">{
        var basePath string
        if len(params) == 1 </span><span class="cov8" title="1">{
                basePath = params[0].(string)
        }</span>
        <span class="cov8" title="1">return &amp;HadeApp{basePath: basePath}, nil</span>
}

// application version
func (app *HadeApp) Version() string <span class="cov0" title="0">{
        return "0.0.1"
}</span>

// base path which is the base folder
func (app *HadeApp) BasePath() string <span class="cov8" title="1">{
        return app.basePath
}</span>

// config folder which contains config
func (app *HadeApp) ConfigPath() string <span class="cov0" title="0">{
        return app.BasePath() + "config/"
}</span>

// environmentPath which contain .env
func (app *HadeApp) EnvironmentPath() string <span class="cov0" title="0">{
        return app.BasePath()
}</span>

// storagePath define storage folder
func (app *HadeApp) StoragePath() string <span class="cov8" title="1">{
        return app.BasePath() + "storage/"
}</span>

// logPath define logPath
func (app *HadeApp) LogPath() string <span class="cov8" title="1">{
        return app.StoragePath() + "logs/"
}</span>

</pre>
		
		<pre class="file" id="file3" style="display: none">package config

import (
        "github.com/jianfengye/hade/framework"
        "github.com/jianfengye/hade/framework/contract"
)

type FakeConfigProvider struct {
        FileName string
        Content  []byte
}

// Register registe a new function for make a service instance
func (provider *FakeConfigProvider) Register(c framework.Container) framework.NewInstance <span class="cov0" title="0">{
        return NewFakeConfig
}</span>

// Boot will called when the service instantiate
func (provider *FakeConfigProvider) Boot(c framework.Container) {<span class="cov0" title="0">
}</span>

// IsDefer define whether the service instantiate when first make or register
func (provider *FakeConfigProvider) IsDefer() bool <span class="cov0" title="0">{
        return false
}</span>

// Params define the necessary params for NewInstance
func (provider *FakeConfigProvider) Params() []interface{} <span class="cov0" title="0">{
        return []interface{}{provider.FileName, provider.Content}
}</span>

// Name define the name for this service
func (provider *FakeConfigProvider) Name() string <span class="cov0" title="0">{
        return contract.ConfigKey
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package config

import (
        "strings"
        "time"

        "github.com/mitchellh/mapstructure"
        "github.com/spf13/cast"
        "gopkg.in/yaml.v2"
)

type FakeConfig struct {
        confMaps map[string]interface{}
}

func NewFakeConfig(params ...interface{}) (interface{}, error) <span class="cov0" title="0">{
        name := params[0].(string)
        bf := params[1].([]byte)
        c := map[string]interface{}{}
        if err := yaml.Unmarshal(bf, &amp;c); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;FakeConfig{
                confMaps: map[string]interface{}{name: c},
        }, nil</span>
}

func (conf *FakeConfig) find(key string) interface{} <span class="cov0" title="0">{
        return searchMap(conf.confMaps, strings.Split(key, "."))
}</span>

// IsExist check setting is exist
func (conf *FakeConfig) IsExist(key string) bool <span class="cov0" title="0">{
        return conf.find(key) != nil
}</span>

// Get a new interface
func (conf *FakeConfig) Get(key string) interface{} <span class="cov0" title="0">{
        return conf.find(key)
}</span>

// GetBool get bool type
func (conf *FakeConfig) GetBool(key string) bool <span class="cov0" title="0">{
        return cast.ToBool(conf.find(key))
}</span>

// GetInt get Int type
func (conf *FakeConfig) GetInt(key string) int <span class="cov0" title="0">{
        return cast.ToInt(conf.find(key))
}</span>

// GetFloat64 get float64
func (conf *FakeConfig) GetFloat64(key string) float64 <span class="cov0" title="0">{
        return cast.ToFloat64(conf.find(key))
}</span>

// GetTime get time type
func (conf *FakeConfig) GetTime(key string) time.Time <span class="cov0" title="0">{
        return cast.ToTime(conf.find(key))
}</span>

// GetString get string typen
func (conf *FakeConfig) GetString(key string) string <span class="cov0" title="0">{
        return cast.ToString(conf.find(key))
}</span>

// GetIntSlice get int slice type
func (conf *FakeConfig) GetIntSlice(key string) []int <span class="cov0" title="0">{
        return cast.ToIntSlice(conf.find(key))
}</span>

// GetStringSlice get string slice type
func (conf *FakeConfig) GetStringSlice(key string) []string <span class="cov0" title="0">{
        return cast.ToStringSlice(conf.find(key))
}</span>

// GetStringMap get map which key is string, value is interface
func (conf *FakeConfig) GetStringMap(key string) map[string]interface{} <span class="cov0" title="0">{
        return cast.ToStringMap(conf.find(key))
}</span>

// GetStringMapString get map which key is string, value is string
func (conf *FakeConfig) GetStringMapString(key string) map[string]string <span class="cov0" title="0">{
        return cast.ToStringMapString(conf.find(key))
}</span>

// GetStringMapStringSlice get map which key is string, value is string slice
func (conf *FakeConfig) GetStringMapStringSlice(key string) map[string][]string <span class="cov0" title="0">{
        return cast.ToStringMapStringSlice(conf.find(key))
}</span>

// Load a config to a struct, val should be an pointer
func (conf *FakeConfig) Load(key string, val interface{}) error <span class="cov0" title="0">{
        return mapstructure.Decode(conf.find(key), val)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package config

import (
        "github.com/jianfengye/hade/framework"
        "github.com/jianfengye/hade/framework/contract"
)

type HadeConfigProvider struct {
        Folder string

        envMaps map[string]string
}

// Register registe a new function for make a service instance
func (provider *HadeConfigProvider) Register(c framework.Container) framework.NewInstance <span class="cov8" title="1">{
        return NewHadeConfig
}</span>

// Boot will called when the service instantiate
func (provider *HadeConfigProvider) Boot(c framework.Container) <span class="cov8" title="1">{
        if provider.Folder == "" &amp;&amp; c.IsBind(contract.AppKey) </span><span class="cov8" title="1">{
                provider.Folder = c.MustMake(contract.AppKey).(contract.App).ConfigPath()
        }</span>
        <span class="cov8" title="1">if c.IsBind(contract.EnvKey) </span><span class="cov8" title="1">{
                provider.envMaps = c.MustMake(contract.EnvKey).(contract.Env).All()
        }</span>
}

// IsDefer define whether the service instantiate when first make or register
func (provider *HadeConfigProvider) IsDefer() bool <span class="cov8" title="1">{
        return false
}</span>

// Params define the necessary params for NewInstance
func (provider *HadeConfigProvider) Params() []interface{} <span class="cov8" title="1">{
        return []interface{}{provider.Folder, provider.envMaps}
}</span>

/// Name define the name for this service
func (provider *HadeConfigProvider) Name() string <span class="cov8" title="1">{
        return contract.ConfigKey
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package config

import (
        "bytes"
        "io/ioutil"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/mitchellh/mapstructure"
        "github.com/spf13/cast"

        "github.com/pkg/errors"
        "gopkg.in/yaml.v2"
)

type HadeConfig struct {
        folder   string
        keyDelim string

        envMaps  map[string]string // envmap
        confMaps map[string]interface{}
        confRaws map[string][]byte
}

func NewHadeConfig(params ...interface{}) (interface{}, error) <span class="cov8" title="1">{
        if len(params) &gt; 2 </span><span class="cov0" title="0">{
                return nil, errors.New("NewHadeConfig params error")
        }</span>

        <span class="cov8" title="1">folder := params[0].(string)
        var envMaps map[string]string
        if len(params) &gt;= 2 </span><span class="cov8" title="1">{
                envMaps = params[1].(map[string]string)
        }</span>

        // check folder exist
        <span class="cov8" title="1">if _, err := os.Stat(folder); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, errors.New("folder " + folder + " not exist: " + err.Error())
        }</span>

        <span class="cov8" title="1">hadeConf := &amp;HadeConfig{
                folder:   folder,
                envMaps:  envMaps,
                confMaps: map[string]interface{}{},
                confRaws: map[string][]byte{},
                keyDelim: ".",
        }

        // read all yml/yaml files in folder
        files, err := ioutil.ReadDir(folder)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.WithStack(err)
        }</span>
        <span class="cov8" title="1">for _, file := range files </span><span class="cov8" title="1">{
                s := strings.Split(file.Name(), ".")
                if len(s) == 2 &amp;&amp; (s[1] == "yaml" || s[1] == "yml") </span><span class="cov8" title="1">{
                        name := s[0]

                        // read file bytes
                        bf, err := ioutil.ReadFile(filepath.Join(folder, file.Name()))
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">hadeConf.confRaws[name] = bf
                        // do replace
                        bf = replace(bf, envMaps)
                        // parse yaml
                        c := map[string]interface{}{}
                        if err := yaml.Unmarshal(bf, &amp;c); err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">hadeConf.confMaps[name] = c</span>
                }
        }
        <span class="cov8" title="1">return hadeConf, nil</span>
}

func replace(content []byte, maps map[string]string) []byte <span class="cov8" title="1">{
        if maps == nil </span><span class="cov8" title="1">{
                return content
        }</span>

        <span class="cov8" title="1">for key, val := range maps </span><span class="cov8" title="1">{
                reKey := "env(" + key + ")"
                content = bytes.ReplaceAll(content, []byte(reKey), []byte(val))
        }</span>

        <span class="cov8" title="1">return content</span>
}

func searchMap(source map[string]interface{}, path []string) interface{} <span class="cov8" title="1">{
        if len(path) == 0 </span><span class="cov0" title="0">{
                return source
        }</span>

        <span class="cov8" title="1">next, ok := source[path[0]]
        if ok </span><span class="cov8" title="1">{
                // Fast path
                if len(path) == 1 </span><span class="cov8" title="1">{
                        return next
                }</span>

                // Nested case
                <span class="cov8" title="1">switch next.(type) </span>{
                case map[interface{}]interface{}:<span class="cov8" title="1">
                        return searchMap(cast.ToStringMap(next), path[1:])</span>
                case map[string]interface{}:<span class="cov8" title="1">
                        // Type assertion is safe here since it is only reached
                        // if the type of `next` is the same as the type being asserted
                        return searchMap(next.(map[string]interface{}), path[1:])</span>
                default:<span class="cov0" title="0">
                        // got a value but nested key expected, return "nil" for not found
                        return nil</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (conf *HadeConfig) find(key string) interface{} <span class="cov8" title="1">{
        return searchMap(conf.confMaps, strings.Split(key, conf.keyDelim))
}</span>

// IsExist check setting is exist
func (conf *HadeConfig) IsExist(key string) bool <span class="cov0" title="0">{
        return conf.find(key) != nil
}</span>

// Get a new interface
func (conf *HadeConfig) Get(key string) interface{} <span class="cov0" title="0">{
        return conf.find(key)
}</span>

// GetBool get bool type
func (conf *HadeConfig) GetBool(key string) bool <span class="cov0" title="0">{
        return cast.ToBool(conf.find(key))
}</span>

// GetInt get Int type
func (conf *HadeConfig) GetInt(key string) int <span class="cov8" title="1">{
        return cast.ToInt(conf.find(key))
}</span>

// GetFloat64 get float64
func (conf *HadeConfig) GetFloat64(key string) float64 <span class="cov8" title="1">{
        return cast.ToFloat64(conf.find(key))
}</span>

// GetTime get time type
func (conf *HadeConfig) GetTime(key string) time.Time <span class="cov0" title="0">{
        return cast.ToTime(conf.find(key))
}</span>

// GetString get string typen
func (conf *HadeConfig) GetString(key string) string <span class="cov8" title="1">{
        return cast.ToString(conf.find(key))
}</span>

// GetIntSlice get int slice type
func (conf *HadeConfig) GetIntSlice(key string) []int <span class="cov0" title="0">{
        return cast.ToIntSlice(conf.find(key))
}</span>

// GetStringSlice get string slice type
func (conf *HadeConfig) GetStringSlice(key string) []string <span class="cov0" title="0">{
        return cast.ToStringSlice(conf.find(key))
}</span>

// GetStringMap get map which key is string, value is interface
func (conf *HadeConfig) GetStringMap(key string) map[string]interface{} <span class="cov8" title="1">{
        return cast.ToStringMap(conf.find(key))
}</span>

// GetStringMapString get map which key is string, value is string
func (conf *HadeConfig) GetStringMapString(key string) map[string]string <span class="cov8" title="1">{
        return cast.ToStringMapString(conf.find(key))
}</span>

// GetStringMapStringSlice get map which key is string, value is string slice
func (conf *HadeConfig) GetStringMapStringSlice(key string) map[string][]string <span class="cov0" title="0">{
        return cast.ToStringMapStringSlice(conf.find(key))
}</span>

// Load a config to a struct, val should be an pointer
func (conf *HadeConfig) Load(key string, val interface{}) error <span class="cov8" title="1">{
        return mapstructure.Decode(conf.find(key), val)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package env

import (
        "github.com/jianfengye/hade/framework"
        "github.com/jianfengye/hade/framework/contract"
)

type HadeEnvProvider struct {
        Folder string
}

// Register registe a new function for make a service instance
func (provider *HadeEnvProvider) Register(c framework.Container) framework.NewInstance <span class="cov8" title="1">{
        return NewHadeEnv
}</span>

// Boot will called when the service instantiate
func (provider *HadeEnvProvider) Boot(c framework.Container) <span class="cov8" title="1">{
        if provider.Folder == "" </span><span class="cov8" title="1">{
                if c.IsBind(contract.AppKey) </span><span class="cov8" title="1">{
                        app := c.MustMake(contract.AppKey).(contract.App)
                        provider.Folder = app.EnvironmentPath()
                }</span>
        }
}

// IsDefer define whether the service instantiate when first make or register
func (provider *HadeEnvProvider) IsDefer() bool <span class="cov8" title="1">{
        return false
}</span>

// Params define the necessary params for NewInstance
func (provider *HadeEnvProvider) Params() []interface{} <span class="cov8" title="1">{
        return []interface{}{provider.Folder}
}</span>

/// Name define the name for this service
func (provider *HadeEnvProvider) Name() string <span class="cov8" title="1">{
        return contract.EnvKey
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package env

import (
        "bufio"
        "bytes"
        "io"
        "os"
        "path"
        "strconv"

        "github.com/pkg/errors"
)


type HadeEnv struct {
        folder string // represent env folder
        
        maps map[string]string
}

// NewHadeEnv have two params: folder and env
// for example: NewHadeEnv("/envfolder/")
// It will read file: /envfolder/.env
// The file have format XXX=XXX
func NewHadeEnv(params ...interface{}) (interface{}, error) <span class="cov8" title="1">{
        if len(params) != 1 </span><span class="cov0" title="0">{
                return nil, errors.New("NewHadeEnv param error")
        }</span>
        
        <span class="cov8" title="1">folder := params[0].(string)
        // parse .env
        file := path.Join(folder, ".env")
        _, err := os.Stat(file)
        if err != nil || os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, errors.New("file " + file + " not exist:" + err.Error())
        }</span>
        <span class="cov8" title="1">fi, err := os.Open(file)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer fi.Close()
        
        hadeEnv := &amp;HadeEnv{
                folder: folder,
                maps : map[string]string{},
        }
        br := bufio.NewReader(fi)
        for </span><span class="cov8" title="1">{
                line, _, c := br.ReadLine()
                if c == io.EOF </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">s := bytes.SplitN(line, []byte{'='}, 2)
                if len(s) &lt; 2 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">key := string(s[0])
                val := string(s[1])
                hadeEnv.maps[key] = val</span>
        }
        <span class="cov8" title="1">return hadeEnv, nil</span>
}
// AppEnv get current environment
func (en *HadeEnv) AppEnv() string <span class="cov8" title="1">{
        return en.Get("APP_ENV")
}</span>

// AppDebug check app is debug open
func (en *HadeEnv) AppDebug() bool <span class="cov8" title="1">{
        b, err := strconv.ParseBool(en.Get("APP_DEBUG"))
        if err == nil </span><span class="cov8" title="1">{
                return b
        }</span>
        <span class="cov0" title="0">return false</span>
}

// AppURL define app url in local
func (en *HadeEnv) AppURL() string <span class="cov0" title="0">{
        return en.Get("APP_URL")
}</span>

// IsExist check setting is exist
func (en *HadeEnv) IsExist(key string) bool <span class="cov0" title="0">{
        _, ok := en.maps[key]
        return ok
}</span>

// Get environment setting, if not exist, return ""
func (en *HadeEnv) Get(key string) string <span class="cov8" title="1">{
        if val, ok := en.maps[key]; ok </span><span class="cov8" title="1">{
                return val
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// All return all settings
func (en *HadeEnv) All() map[string]string <span class="cov0" title="0">{
        return en.maps        
}</pre>
		
		<pre class="file" id="file9" style="display: none">package gorm

import (
        "github.com/jianfengye/hade/framework"
        "github.com/jianfengye/hade/framework/contract"
)

type GormServiceProvider struct {
        Config map[string]string
        framework.ServiceProvider
}

func (sp *GormServiceProvider) Name() string <span class="cov8" title="1">{
        return "gorm"
}</span>

func (sp *GormServiceProvider) Register(c framework.Container) framework.NewInstance <span class="cov8" title="1">{
        return NewGormDB
}</span>

func (sp *GormServiceProvider) IsDefer() bool <span class="cov8" title="1">{
        return true
}</span>

func (sp *GormServiceProvider) Params() []interface{} <span class="cov0" title="0">{
        return []interface{}{sp.Config}
}</span>

func (sp *GormServiceProvider) Boot(c framework.Container) <span class="cov8" title="1">{
        if sp.Config == nil </span><span class="cov8" title="1">{
                if c.IsBind(contract.ConfigKey) </span><span class="cov8" title="1">{
                        config := c.MustMake(contract.ConfigKey).(contract.Config)
                        if config.IsExist("database.default") </span><span class="cov8" title="1">{
                                sp.Config = config.GetStringMapString("database.default")
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package gorm

import (
        "fmt"

        "github.com/jinzhu/gorm"
        _ "github.com/jinzhu/gorm/dialects/mysql"

        _ "github.com/jinzhu/gorm/dialects/mssql"
        _ "github.com/jinzhu/gorm/dialects/postgres"
        _ "github.com/jinzhu/gorm/dialects/sqlite"
        "github.com/pkg/errors"
)

func NewGormDB(params ...interface{}) (interface{}, error) <span class="cov8" title="1">{
        c := params[0].(map[string]string)
        if c == nil </span><span class="cov0" title="0">{
                return nil, errors.New("config is empty")
        }</span>
        <span class="cov8" title="1">s := fmt.Sprintf("%s:%s@(%s)/%s?charset=%s&amp;parseTime=True&amp;loc=Local", c["username"], c["password"], c["hostname"], c["database"], c["charset"])
        db, err := gorm.Open(c["driver"], s)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "new gorm error")
        }</span>
        <span class="cov8" title="1">return db, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package log

import (
        "strings"

        "github.com/jianfengye/hade/framework"
        "github.com/jianfengye/hade/framework/contract"
        "github.com/jianfengye/hade/framework/provider/log/formatter"
        "github.com/jianfengye/hade/framework/provider/log/services"
)

type HadeLogServiceProvider struct {
        framework.ServiceProvider

        driver  string // driver
        configs map[string]interface{}

        // common config for log
        Formatter  contract.Formatter
        Level      contract.LogLevel
        CtxFielder contract.CtxFielder
}

// Register registe a new function for make a service instance
func (l *HadeLogServiceProvider) Register(c framework.Container) framework.NewInstance <span class="cov8" title="1">{
        if !c.IsBind(contract.ConfigKey) </span><span class="cov0" title="0">{
                return services.NewHadeConsoleLog
        }</span>

        <span class="cov8" title="1">cs := c.MustMake(contract.ConfigKey).(contract.Config)
        l.driver = strings.ToLower(cs.GetString("log.driver"))
        l.configs = cs.GetStringMap("log")

        switch l.driver </span>{
        case "single":<span class="cov8" title="1">
                return services.NewHadeSingleLog</span>
        case "rotate":<span class="cov8" title="1">
                return services.NewHadeRotateLog</span>
        case "console":<span class="cov0" title="0">
                return services.NewHadeConsoleLog</span>
        default:<span class="cov0" title="0">
                return services.NewHadeConsoleLog</span>
        }
}

// Boot will called when the service instantiate
func (l *HadeLogServiceProvider) Boot(c framework.Container) <span class="cov8" title="1">{
        // Set Formatter/Level/CtxFielder
        if l.Formatter == nil </span><span class="cov8" title="1">{
                l.Formatter = formatter.TextFormatter
                if t, ok := l.configs["formatter"]; ok </span><span class="cov0" title="0">{
                        v := t.(string)
                        if v == "json" </span><span class="cov0" title="0">{
                                l.Formatter = formatter.JsonFormatter
                        }</span> else<span class="cov0" title="0"> if v == "text" </span><span class="cov0" title="0">{
                                l.Formatter = formatter.TextFormatter
                        }</span>
                }
        }
        <span class="cov8" title="1">if l.Level == contract.UnknownLevel </span><span class="cov8" title="1">{
                if t, ok := l.configs["level"]; ok </span><span class="cov0" title="0">{
                        l.Level = logLevel(t.(string))
                }</span>
                <span class="cov8" title="1">if l.Level == contract.UnknownLevel </span><span class="cov8" title="1">{
                        l.Level = contract.InfoLevel
                }</span>
        }

        <span class="cov8" title="1">app := c.MustMake(contract.AppKey).(contract.App)

        switch l.driver </span>{
        case "single":<span class="cov8" title="1">
                // check configs default: folder/file
                if _, ok := l.configs["folder"]; !ok </span><span class="cov8" title="1">{
                        l.configs["folder"] = app.LogPath()
                }</span>
                <span class="cov8" title="1">if _, ok := l.configs["file"]; !ok </span><span class="cov8" title="1">{
                        l.configs["file"] = "hade.log"
                }</span>
        case "rotate":<span class="cov8" title="1">
                // check configs default: folder/file
                if _, ok := l.configs["folder"]; !ok </span><span class="cov8" title="1">{
                        l.configs["folder"] = app.LogPath()
                }</span>
                <span class="cov8" title="1">if _, ok := l.configs["file"]; !ok </span><span class="cov0" title="0">{
                        l.configs["file"] = "hade.log"
                }</span>
                <span class="cov8" title="1">if _, ok := l.configs["max_files"]; !ok </span><span class="cov0" title="0">{
                        l.configs["max_files"] = 30
                }</span>
                <span class="cov8" title="1">if _, ok := l.configs["date_format"]; !ok </span><span class="cov0" title="0">{
                        l.configs["date_format"] = "ymd"
                }</span>
        }
}

// IsDefer define whether the service instantiate when first make or register
func (l *HadeLogServiceProvider) IsDefer() bool <span class="cov8" title="1">{
        return false
}</span>

// Params define the necessary params for NewInstance
func (l *HadeLogServiceProvider) Params() []interface{} <span class="cov8" title="1">{
        // param sequence: level, ctxFielder, Formatter, map[string]string(folder/file)
        return []interface{}{l.Level, l.CtxFielder, l.Formatter, l.configs}
}</span>

/// Name define the name for this service
func (l *HadeLogServiceProvider) Name() string <span class="cov8" title="1">{
        return contract.LogKey
}</span>

// logLevel get level from string
func logLevel(config string) contract.LogLevel <span class="cov0" title="0">{
        switch strings.ToLower(config) </span>{
        case "panic":<span class="cov0" title="0">
                return contract.PanicLevel</span>
        case "fatal":<span class="cov0" title="0">
                return contract.FatalLevel</span>
        case "error":<span class="cov0" title="0">
                return contract.ErrorLevel</span>
        case "warn":<span class="cov0" title="0">
                return contract.WarnLevel</span>
        case "info":<span class="cov0" title="0">
                return contract.InfoLevel</span>
        case "debug":<span class="cov0" title="0">
                return contract.DebugLevel</span>
        case "trace":<span class="cov0" title="0">
                return contract.TraceLevel</span>
        }
        <span class="cov0" title="0">return contract.UnknownLevel</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package framework

import (
        "github.com/jianfengye/hade/framework/contract"
)

// ConfigService get ConfigService which provider by name
func (hade *HadeContainer) ConfigService() (contract.Config, error) <span class="cov0" title="0">{
        ins, err := hade.Make("config")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if ins != nil </span><span class="cov0" title="0">{
                if c, ok := ins.(contract.Config); ok </span><span class="cov0" title="0">{
                        return c, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Copyright 2014 Manu Martinez-Almeida.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package gin

import (
        "crypto/subtle"
        "encoding/base64"
        "net/http"
        "strconv"
)

// AuthUserKey is the cookie name for user credential in basic auth.
const AuthUserKey = "user"

// Accounts defines a key/value for user/pass list of authorized logins.
type Accounts map[string]string

type authPair struct {
        value string
        user  string
}

type authPairs []authPair

func (a authPairs) searchCredential(authValue string) (string, bool) <span class="cov8" title="1">{
        if authValue == "" </span><span class="cov8" title="1">{
                return "", false
        }</span>
        <span class="cov8" title="1">for _, pair := range a </span><span class="cov8" title="1">{
                if pair.value == authValue </span><span class="cov8" title="1">{
                        return pair.user, true
                }</span>
        }
        <span class="cov8" title="1">return "", false</span>
}

// BasicAuthForRealm returns a Basic HTTP Authorization middleware. It takes as arguments a map[string]string where
// the key is the user name and the value is the password, as well as the name of the Realm.
// If the realm is empty, "Authorization Required" will be used by default.
// (see http://tools.ietf.org/html/rfc2617#section-1.2)
func BasicAuthForRealm(accounts Accounts, realm string) HandlerFunc <span class="cov8" title="1">{
        if realm == "" </span><span class="cov8" title="1">{
                realm = "Authorization Required"
        }</span>
        <span class="cov8" title="1">realm = "Basic realm=" + strconv.Quote(realm)
        pairs := processAccounts(accounts)
        return func(c *Context) </span><span class="cov8" title="1">{
                // Search user in the slice of allowed credentials
                user, found := pairs.searchCredential(c.requestHeader("Authorization"))
                if !found </span><span class="cov8" title="1">{
                        // Credentials doesn't match, we return 401 and abort handlers chain.
                        c.Header("WWW-Authenticate", realm)
                        c.AbortWithStatus(http.StatusUnauthorized)
                        return
                }</span>

                // The user credentials was found, set user's id to key AuthUserKey in this context, the user's id can be read later using
                // c.MustGet(gin.AuthUserKey).
                <span class="cov8" title="1">c.Set(AuthUserKey, user)</span>
        }
}

// BasicAuth returns a Basic HTTP Authorization middleware. It takes as argument a map[string]string where
// the key is the user name and the value is the password.
func BasicAuth(accounts Accounts) HandlerFunc <span class="cov8" title="1">{
        return BasicAuthForRealm(accounts, "")
}</span>

func processAccounts(accounts Accounts) authPairs <span class="cov8" title="1">{
        assert1(len(accounts) &gt; 0, "Empty list of authorized credentials")
        pairs := make(authPairs, 0, len(accounts))
        for user, password := range accounts </span><span class="cov8" title="1">{
                assert1(user != "", "User can not be empty")
                value := authorizationHeader(user, password)
                pairs = append(pairs, authPair{
                        value: value,
                        user:  user,
                })
        }</span>
        <span class="cov8" title="1">return pairs</span>
}

func authorizationHeader(user, password string) string <span class="cov8" title="1">{
        base := user + ":" + password
        return "Basic " + base64.StdEncoding.EncodeToString([]byte(base))
}</span>

func secureCompare(given, actual string) bool <span class="cov8" title="1">{
        if subtle.ConstantTimeEq(int32(len(given)), int32(len(actual))) == 1 </span><span class="cov8" title="1">{
                return subtle.ConstantTimeCompare([]byte(given), []byte(actual)) == 1
        }</span>
        // Securely compare actual to itself to keep constant time, but always return false.
        <span class="cov8" title="1">return subtle.ConstantTimeCompare([]byte(actual), []byte(actual)) == 1 &amp;&amp; false</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Copyright 2014 Manu Martinez-Almeida.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package binding

import "net/http"

// Content-Type MIME of the most common data formats.
const (
        MIMEJSON              = "application/json"
        MIMEHTML              = "text/html"
        MIMEXML               = "application/xml"
        MIMEXML2              = "text/xml"
        MIMEPlain             = "text/plain"
        MIMEPOSTForm          = "application/x-www-form-urlencoded"
        MIMEMultipartPOSTForm = "multipart/form-data"
        MIMEPROTOBUF          = "application/x-protobuf"
        MIMEMSGPACK           = "application/x-msgpack"
        MIMEMSGPACK2          = "application/msgpack"
        MIMEYAML              = "application/x-yaml"
)

// Binding describes the interface which needs to be implemented for binding the
// data present in the request such as JSON request body, query parameters or
// the form POST.
type Binding interface {
        Name() string
        Bind(*http.Request, interface{}) error
}

// BindingBody adds BindBody method to Binding. BindBody is similar with Bind,
// but it reads the body from supplied bytes instead of req.Body.
type BindingBody interface {
        Binding
        BindBody([]byte, interface{}) error
}

// BindingUri adds BindUri method to Binding. BindUri is similar with Bind,
// but it read the Params.
type BindingUri interface {
        Name() string
        BindUri(map[string][]string, interface{}) error
}

// StructValidator is the minimal interface which needs to be implemented in
// order for it to be used as the validator engine for ensuring the correctness
// of the request. Gin provides a default implementation for this using
// https://github.com/go-playground/validator/tree/v8.18.2.
type StructValidator interface {
        // ValidateStruct can receive any kind of type and it should never panic, even if the configuration is not right.
        // If the received type is not a struct, any validation should be skipped and nil must be returned.
        // If the received type is a struct or pointer to a struct, the validation should be performed.
        // If the struct is not valid or the validation itself fails, a descriptive error should be returned.
        // Otherwise nil must be returned.
        ValidateStruct(interface{}) error

        // Engine returns the underlying validator engine which powers the
        // StructValidator implementation.
        Engine() interface{}
}

// Validator is the default validator which implements the StructValidator
// interface. It uses https://github.com/go-playground/validator/tree/v8.18.2
// under the hood.
var Validator StructValidator = &amp;defaultValidator{}

// These implement the Binding interface and can be used to bind the data
// present in the request to struct instances.
var (
        JSON          = jsonBinding{}
        XML           = xmlBinding{}
        Form          = formBinding{}
        Query         = queryBinding{}
        FormPost      = formPostBinding{}
        FormMultipart = formMultipartBinding{}
        ProtoBuf      = protobufBinding{}
        MsgPack       = msgpackBinding{}
        YAML          = yamlBinding{}
        Uri           = uriBinding{}
)

// Default returns the appropriate Binding instance based on the HTTP method
// and the content type.
func Default(method, contentType string) Binding <span class="cov8" title="1">{
        if method == "GET" </span><span class="cov8" title="1">{
                return Form
        }</span>

        <span class="cov8" title="1">switch contentType </span>{
        case MIMEJSON:<span class="cov8" title="1">
                return JSON</span>
        case MIMEXML, MIMEXML2:<span class="cov8" title="1">
                return XML</span>
        case MIMEPROTOBUF:<span class="cov8" title="1">
                return ProtoBuf</span>
        case MIMEMSGPACK, MIMEMSGPACK2:<span class="cov8" title="1">
                return MsgPack</span>
        case MIMEYAML:<span class="cov8" title="1">
                return YAML</span>
        case MIMEMultipartPOSTForm:<span class="cov8" title="1">
                return FormMultipart</span>
        default:<span class="cov8" title="1"> // case MIMEPOSTForm:
                return Form</span>
        }
}

func validate(obj interface{}) error <span class="cov8" title="1">{
        if Validator == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return Validator.ValidateStruct(obj)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Copyright 2017 Manu Martinez-Almeida.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package binding

import (
        "reflect"
        "sync"

        "gopkg.in/go-playground/validator.v8"
)

type defaultValidator struct {
        once     sync.Once
        validate *validator.Validate
}

var _ StructValidator = &amp;defaultValidator{}

// ValidateStruct receives any kind of type, but only performed struct or pointer to struct type.
func (v *defaultValidator) ValidateStruct(obj interface{}) error <span class="cov8" title="1">{
        value := reflect.ValueOf(obj)
        valueType := value.Kind()
        if valueType == reflect.Ptr </span><span class="cov8" title="1">{
                valueType = value.Elem().Kind()
        }</span>
        <span class="cov8" title="1">if valueType == reflect.Struct </span><span class="cov8" title="1">{
                v.lazyinit()
                if err := v.validate.Struct(obj); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Engine returns the underlying validator engine which powers the default
// Validator instance. This is useful if you want to register custom validations
// or struct level validations. See validator GoDoc for more info -
// https://godoc.org/gopkg.in/go-playground/validator.v8
func (v *defaultValidator) Engine() interface{} <span class="cov8" title="1">{
        v.lazyinit()
        return v.validate
}</span>

func (v *defaultValidator) lazyinit() <span class="cov8" title="1">{
        v.once.Do(func() </span><span class="cov8" title="1">{
                config := &amp;validator.Config{TagName: "binding"}
                v.validate = validator.New(config)
        }</span>)
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Copyright 2014 Manu Martinez-Almeida.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package binding

import (
        "mime/multipart"
        "net/http"
        "reflect"
)

const defaultMemory = 32 * 1024 * 1024

type formBinding struct{}
type formPostBinding struct{}
type formMultipartBinding struct{}

func (formBinding) Name() string <span class="cov8" title="1">{
        return "form"
}</span>

func (formBinding) Bind(req *http.Request, obj interface{}) error <span class="cov8" title="1">{
        if err := req.ParseForm(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := req.ParseMultipartForm(defaultMemory); err != nil </span><span class="cov8" title="1">{
                if err != http.ErrNotMultipart </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">if err := mapForm(obj, req.Form); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return validate(obj)</span>
}

func (formPostBinding) Name() string <span class="cov8" title="1">{
        return "form-urlencoded"
}</span>

func (formPostBinding) Bind(req *http.Request, obj interface{}) error <span class="cov8" title="1">{
        if err := req.ParseForm(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := mapForm(obj, req.PostForm); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return validate(obj)</span>
}

func (formMultipartBinding) Name() string <span class="cov8" title="1">{
        return "multipart/form-data"
}</span>

func (formMultipartBinding) Bind(req *http.Request, obj interface{}) error <span class="cov8" title="1">{
        if err := req.ParseMultipartForm(defaultMemory); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := mappingByPtr(obj, (*multipartRequest)(req), "form"); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return validate(obj)</span>
}

type multipartRequest http.Request

var _ setter = (*multipartRequest)(nil)

var (
        multipartFileHeaderStructType = reflect.TypeOf(multipart.FileHeader{})
)

// TrySet tries to set a value by the multipart request with the binding a form file
func (r *multipartRequest) TrySet(value reflect.Value, field reflect.StructField, key string, opt setOptions) (isSetted bool, err error) <span class="cov8" title="1">{
        if value.Type() == multipartFileHeaderStructType </span><span class="cov8" title="1">{
                _, file, err := (*http.Request)(r).FormFile(key)
                if err != nil </span><span class="cov8" title="1">{
                        return false, err
                }</span>
                <span class="cov8" title="1">if file != nil </span><span class="cov8" title="1">{
                        value.Set(reflect.ValueOf(*file))
                        return true, nil
                }</span>
        }

        <span class="cov8" title="1">return setByForm(value, field, r.MultipartForm.Value, key, opt)</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Copyright 2014 Manu Martinez-Almeida.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package binding

import (
        "errors"
        "fmt"
        "reflect"
        "strconv"
        "strings"
        "time"

        "github.com/jianfengye/hade/gin/internal/json"
)

var errUnknownType = errors.New("Unknown type")

func mapUri(ptr interface{}, m map[string][]string) error <span class="cov8" title="1">{
        return mapFormByTag(ptr, m, "uri")
}</span>

func mapForm(ptr interface{}, form map[string][]string) error <span class="cov8" title="1">{
        return mapFormByTag(ptr, form, "form")
}</span>

var emptyField = reflect.StructField{}

func mapFormByTag(ptr interface{}, form map[string][]string, tag string) error <span class="cov8" title="1">{
        return mappingByPtr(ptr, formSource(form), tag)
}</span>

// setter tries to set value on a walking by fields of a struct
type setter interface {
        TrySet(value reflect.Value, field reflect.StructField, key string, opt setOptions) (isSetted bool, err error)
}

type formSource map[string][]string

var _ setter = formSource(nil)

// TrySet tries to set a value by request's form source (like map[string][]string)
func (form formSource) TrySet(value reflect.Value, field reflect.StructField, tagValue string, opt setOptions) (isSetted bool, err error) <span class="cov8" title="1">{
        return setByForm(value, field, form, tagValue, opt)
}</span>

func mappingByPtr(ptr interface{}, setter setter, tag string) error <span class="cov8" title="1">{
        _, err := mapping(reflect.ValueOf(ptr), emptyField, setter, tag)
        return err
}</span>

func mapping(value reflect.Value, field reflect.StructField, setter setter, tag string) (bool, error) <span class="cov8" title="1">{
        var vKind = value.Kind()

        if vKind == reflect.Ptr </span><span class="cov8" title="1">{
                var isNew bool
                vPtr := value
                if value.IsNil() </span><span class="cov8" title="1">{
                        isNew = true
                        vPtr = reflect.New(value.Type().Elem())
                }</span>
                <span class="cov8" title="1">isSetted, err := mapping(vPtr.Elem(), field, setter, tag)
                if err != nil </span><span class="cov8" title="1">{
                        return false, err
                }</span>
                <span class="cov8" title="1">if isNew &amp;&amp; isSetted </span><span class="cov8" title="1">{
                        value.Set(vPtr)
                }</span>
                <span class="cov8" title="1">return isSetted, nil</span>
        }

        <span class="cov8" title="1">ok, err := tryToSetValue(value, field, setter, tag)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">if ok </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        <span class="cov8" title="1">if vKind == reflect.Struct </span><span class="cov8" title="1">{
                tValue := value.Type()

                var isSetted bool
                for i := 0; i &lt; value.NumField(); i++ </span><span class="cov8" title="1">{
                        if !value.Field(i).CanSet() </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">ok, err := mapping(value.Field(i), tValue.Field(i), setter, tag)
                        if err != nil </span><span class="cov8" title="1">{
                                return false, err
                        }</span>
                        <span class="cov8" title="1">isSetted = isSetted || ok</span>
                }
                <span class="cov8" title="1">return isSetted, nil</span>
        }
        <span class="cov8" title="1">return false, nil</span>
}

type setOptions struct {
        isDefaultExists bool
        defaultValue    string
}

func tryToSetValue(value reflect.Value, field reflect.StructField, setter setter, tag string) (bool, error) <span class="cov8" title="1">{
        var tagValue string
        var setOpt setOptions

        tagValue = field.Tag.Get(tag)
        tagValue, opts := head(tagValue, ",")

        if tagValue == "-" </span><span class="cov8" title="1">{ // just ignoring this field
                return false, nil
        }</span>
        <span class="cov8" title="1">if tagValue == "" </span><span class="cov8" title="1">{ // default value is FieldName
                tagValue = field.Name
        }</span>
        <span class="cov8" title="1">if tagValue == "" </span><span class="cov8" title="1">{ // when field is "emptyField" variable
                return false, nil
        }</span>

        <span class="cov8" title="1">var opt string
        for len(opts) &gt; 0 </span><span class="cov8" title="1">{
                opt, opts = head(opts, ",")

                k, v := head(opt, "=")
                switch k </span>{
                case "default":<span class="cov8" title="1">
                        setOpt.isDefaultExists = true
                        setOpt.defaultValue = v</span>
                }
        }

        <span class="cov8" title="1">return setter.TrySet(value, field, tagValue, setOpt)</span>
}

func setByForm(value reflect.Value, field reflect.StructField, form map[string][]string, tagValue string, opt setOptions) (isSetted bool, err error) <span class="cov8" title="1">{
        vs, ok := form[tagValue]
        if !ok &amp;&amp; !opt.isDefaultExists </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">switch value.Kind() </span>{
        case reflect.Slice:<span class="cov8" title="1">
                if !ok </span><span class="cov8" title="1">{
                        vs = []string{opt.defaultValue}
                }</span>
                <span class="cov8" title="1">return true, setSlice(vs, value, field)</span>
        case reflect.Array:<span class="cov8" title="1">
                if !ok </span><span class="cov8" title="1">{
                        vs = []string{opt.defaultValue}
                }</span>
                <span class="cov8" title="1">if len(vs) != value.Len() </span><span class="cov8" title="1">{
                        return false, fmt.Errorf("%q is not valid value for %s", vs, value.Type().String())
                }</span>
                <span class="cov8" title="1">return true, setArray(vs, value, field)</span>
        default:<span class="cov8" title="1">
                var val string
                if !ok </span><span class="cov8" title="1">{
                        val = opt.defaultValue
                }</span>

                <span class="cov8" title="1">if len(vs) &gt; 0 </span><span class="cov8" title="1">{
                        val = vs[0]
                }</span>
                <span class="cov8" title="1">return true, setWithProperType(val, value, field)</span>
        }
}

func setWithProperType(val string, value reflect.Value, field reflect.StructField) error <span class="cov8" title="1">{
        switch value.Kind() </span>{
        case reflect.Int:<span class="cov8" title="1">
                return setIntField(val, 0, value)</span>
        case reflect.Int8:<span class="cov8" title="1">
                return setIntField(val, 8, value)</span>
        case reflect.Int16:<span class="cov8" title="1">
                return setIntField(val, 16, value)</span>
        case reflect.Int32:<span class="cov8" title="1">
                return setIntField(val, 32, value)</span>
        case reflect.Int64:<span class="cov8" title="1">
                switch value.Interface().(type) </span>{
                case time.Duration:<span class="cov8" title="1">
                        return setTimeDuration(val, value, field)</span>
                }
                <span class="cov8" title="1">return setIntField(val, 64, value)</span>
        case reflect.Uint:<span class="cov8" title="1">
                return setUintField(val, 0, value)</span>
        case reflect.Uint8:<span class="cov8" title="1">
                return setUintField(val, 8, value)</span>
        case reflect.Uint16:<span class="cov8" title="1">
                return setUintField(val, 16, value)</span>
        case reflect.Uint32:<span class="cov8" title="1">
                return setUintField(val, 32, value)</span>
        case reflect.Uint64:<span class="cov8" title="1">
                return setUintField(val, 64, value)</span>
        case reflect.Bool:<span class="cov8" title="1">
                return setBoolField(val, value)</span>
        case reflect.Float32:<span class="cov8" title="1">
                return setFloatField(val, 32, value)</span>
        case reflect.Float64:<span class="cov8" title="1">
                return setFloatField(val, 64, value)</span>
        case reflect.String:<span class="cov8" title="1">
                value.SetString(val)</span>
        case reflect.Struct:<span class="cov8" title="1">
                switch value.Interface().(type) </span>{
                case time.Time:<span class="cov8" title="1">
                        return setTimeField(val, field, value)</span>
                }
                <span class="cov8" title="1">return json.Unmarshal([]byte(val), value.Addr().Interface())</span>
        case reflect.Map:<span class="cov8" title="1">
                return json.Unmarshal([]byte(val), value.Addr().Interface())</span>
        default:<span class="cov8" title="1">
                return errUnknownType</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func setIntField(val string, bitSize int, field reflect.Value) error <span class="cov8" title="1">{
        if val == "" </span><span class="cov8" title="1">{
                val = "0"
        }</span>
        <span class="cov8" title="1">intVal, err := strconv.ParseInt(val, 10, bitSize)
        if err == nil </span><span class="cov8" title="1">{
                field.SetInt(intVal)
        }</span>
        <span class="cov8" title="1">return err</span>
}

func setUintField(val string, bitSize int, field reflect.Value) error <span class="cov8" title="1">{
        if val == "" </span><span class="cov8" title="1">{
                val = "0"
        }</span>
        <span class="cov8" title="1">uintVal, err := strconv.ParseUint(val, 10, bitSize)
        if err == nil </span><span class="cov8" title="1">{
                field.SetUint(uintVal)
        }</span>
        <span class="cov8" title="1">return err</span>
}

func setBoolField(val string, field reflect.Value) error <span class="cov8" title="1">{
        if val == "" </span><span class="cov8" title="1">{
                val = "false"
        }</span>
        <span class="cov8" title="1">boolVal, err := strconv.ParseBool(val)
        if err == nil </span><span class="cov8" title="1">{
                field.SetBool(boolVal)
        }</span>
        <span class="cov8" title="1">return err</span>
}

func setFloatField(val string, bitSize int, field reflect.Value) error <span class="cov8" title="1">{
        if val == "" </span><span class="cov8" title="1">{
                val = "0.0"
        }</span>
        <span class="cov8" title="1">floatVal, err := strconv.ParseFloat(val, bitSize)
        if err == nil </span><span class="cov8" title="1">{
                field.SetFloat(floatVal)
        }</span>
        <span class="cov8" title="1">return err</span>
}

func setTimeField(val string, structField reflect.StructField, value reflect.Value) error <span class="cov8" title="1">{
        timeFormat := structField.Tag.Get("time_format")
        if timeFormat == "" </span><span class="cov8" title="1">{
                timeFormat = time.RFC3339
        }</span>

        <span class="cov8" title="1">if val == "" </span><span class="cov8" title="1">{
                value.Set(reflect.ValueOf(time.Time{}))
                return nil
        }</span>

        <span class="cov8" title="1">l := time.Local
        if isUTC, _ := strconv.ParseBool(structField.Tag.Get("time_utc")); isUTC </span><span class="cov8" title="1">{
                l = time.UTC
        }</span>

        <span class="cov8" title="1">if locTag := structField.Tag.Get("time_location"); locTag != "" </span><span class="cov8" title="1">{
                loc, err := time.LoadLocation(locTag)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">l = loc</span>
        }

        <span class="cov8" title="1">t, err := time.ParseInLocation(timeFormat, val, l)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">value.Set(reflect.ValueOf(t))
        return nil</span>
}

func setArray(vals []string, value reflect.Value, field reflect.StructField) error <span class="cov8" title="1">{
        for i, s := range vals </span><span class="cov8" title="1">{
                err := setWithProperType(s, value.Index(i), field)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func setSlice(vals []string, value reflect.Value, field reflect.StructField) error <span class="cov8" title="1">{
        slice := reflect.MakeSlice(value.Type(), len(vals), len(vals))
        err := setArray(vals, slice, field)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">value.Set(slice)
        return nil</span>
}

func setTimeDuration(val string, value reflect.Value, field reflect.StructField) error <span class="cov8" title="1">{
        d, err := time.ParseDuration(val)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">value.Set(reflect.ValueOf(d))
        return nil</span>
}

func head(str, sep string) (head string, tail string) <span class="cov8" title="1">{
        idx := strings.Index(str, sep)
        if idx &lt; 0 </span><span class="cov8" title="1">{
                return str, ""
        }</span>
        <span class="cov8" title="1">return str[:idx], str[idx+len(sep):]</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Copyright 2014 Manu Martinez-Almeida.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package binding

import (
        "bytes"
        "fmt"
        "io"
        "net/http"

        "github.com/jianfengye/hade/gin/internal/json"
)

// EnableDecoderUseNumber is used to call the UseNumber method on the JSON
// Decoder instance. UseNumber causes the Decoder to unmarshal a number into an
// interface{} as a Number instead of as a float64.
var EnableDecoderUseNumber = false

type jsonBinding struct{}

func (jsonBinding) Name() string <span class="cov8" title="1">{
        return "json"
}</span>

func (jsonBinding) Bind(req *http.Request, obj interface{}) error <span class="cov8" title="1">{
        if req == nil || req.Body == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid request")
        }</span>
        <span class="cov8" title="1">return decodeJSON(req.Body, obj)</span>
}

func (jsonBinding) BindBody(body []byte, obj interface{}) error <span class="cov8" title="1">{
        return decodeJSON(bytes.NewReader(body), obj)
}</span>

func decodeJSON(r io.Reader, obj interface{}) error <span class="cov8" title="1">{
        decoder := json.NewDecoder(r)
        if EnableDecoderUseNumber </span><span class="cov8" title="1">{
                decoder.UseNumber()
        }</span>
        <span class="cov8" title="1">if err := decoder.Decode(obj); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return validate(obj)</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Copyright 2017 Manu Martinez-Almeida.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package binding

import (
        "bytes"
        "io"
        "net/http"

        "github.com/ugorji/go/codec"
)

type msgpackBinding struct{}

func (msgpackBinding) Name() string <span class="cov8" title="1">{
        return "msgpack"
}</span>

func (msgpackBinding) Bind(req *http.Request, obj interface{}) error <span class="cov8" title="1">{
        return decodeMsgPack(req.Body, obj)
}</span>

func (msgpackBinding) BindBody(body []byte, obj interface{}) error <span class="cov8" title="1">{
        return decodeMsgPack(bytes.NewReader(body), obj)
}</span>

func decodeMsgPack(r io.Reader, obj interface{}) error <span class="cov8" title="1">{
        cdc := new(codec.MsgpackHandle)
        if err := codec.NewDecoder(r, cdc).Decode(&amp;obj); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return validate(obj)</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Copyright 2014 Manu Martinez-Almeida.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package binding

import (
        "io/ioutil"
        "net/http"

        "github.com/golang/protobuf/proto"
)

type protobufBinding struct{}

func (protobufBinding) Name() string <span class="cov8" title="1">{
        return "protobuf"
}</span>

func (b protobufBinding) Bind(req *http.Request, obj interface{}) error <span class="cov8" title="1">{
        buf, err := ioutil.ReadAll(req.Body)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return b.BindBody(buf, obj)</span>
}

func (protobufBinding) BindBody(body []byte, obj interface{}) error <span class="cov8" title="1">{
        if err := proto.Unmarshal(body, obj.(proto.Message)); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        // Here it's same to return validate(obj), but util now we can't add
        // `binding:""` to the struct which automatically generate by gen-proto
        <span class="cov8" title="1">return nil</span>
        // return validate(obj)
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Copyright 2017 Manu Martinez-Almeida.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package binding

import "net/http"

type queryBinding struct{}

func (queryBinding) Name() string <span class="cov8" title="1">{
        return "query"
}</span>

func (queryBinding) Bind(req *http.Request, obj interface{}) error <span class="cov8" title="1">{
        values := req.URL.Query()
        if err := mapForm(obj, values); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return validate(obj)</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Copyright 2018 Gin Core Team.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package binding

type uriBinding struct{}

func (uriBinding) Name() string <span class="cov8" title="1">{
        return "uri"
}</span>

func (uriBinding) BindUri(m map[string][]string, obj interface{}) error <span class="cov8" title="1">{
        if err := mapUri(obj, m); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return validate(obj)</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Copyright 2014 Manu Martinez-Almeida.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package binding

import (
        "bytes"
        "encoding/xml"
        "io"
        "net/http"
)

type xmlBinding struct{}

func (xmlBinding) Name() string <span class="cov8" title="1">{
        return "xml"
}</span>

func (xmlBinding) Bind(req *http.Request, obj interface{}) error <span class="cov8" title="1">{
        return decodeXML(req.Body, obj)
}</span>

func (xmlBinding) BindBody(body []byte, obj interface{}) error <span class="cov8" title="1">{
        return decodeXML(bytes.NewReader(body), obj)
}</span>
func decodeXML(r io.Reader, obj interface{}) error <span class="cov8" title="1">{
        decoder := xml.NewDecoder(r)
        if err := decoder.Decode(obj); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return validate(obj)</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Copyright 2018 Gin Core Team.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package binding

import (
        "bytes"
        "io"
        "net/http"

        "gopkg.in/yaml.v2"
)

type yamlBinding struct{}

func (yamlBinding) Name() string <span class="cov8" title="1">{
        return "yaml"
}</span>

func (yamlBinding) Bind(req *http.Request, obj interface{}) error <span class="cov8" title="1">{
        return decodeYAML(req.Body, obj)
}</span>

func (yamlBinding) BindBody(body []byte, obj interface{}) error <span class="cov8" title="1">{
        return decodeYAML(bytes.NewReader(body), obj)
}</span>

func decodeYAML(r io.Reader, obj interface{}) error <span class="cov8" title="1">{
        decoder := yaml.NewDecoder(r)
        if err := decoder.Decode(obj); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return validate(obj)</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Copyright 2014 Manu Martinez-Almeida.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package gin

import (
        "errors"
        "fmt"
        "io"
        "io/ioutil"
        "math"
        "mime/multipart"
        "net"
        "net/http"
        "net/url"
        "os"
        "strings"
        "time"

        "github.com/gin-contrib/sse"
        "github.com/jianfengye/hade/framework"
        "github.com/jianfengye/hade/gin/binding"
        "github.com/jianfengye/hade/gin/render"
)

// Content-Type MIME of the most common data formats.
const (
        MIMEJSON              = binding.MIMEJSON
        MIMEHTML              = binding.MIMEHTML
        MIMEXML               = binding.MIMEXML
        MIMEXML2              = binding.MIMEXML2
        MIMEPlain             = binding.MIMEPlain
        MIMEPOSTForm          = binding.MIMEPOSTForm
        MIMEMultipartPOSTForm = binding.MIMEMultipartPOSTForm
        MIMEYAML              = binding.MIMEYAML
        BodyBytesKey          = "_gin-gonic/gin/bodybyteskey"
)

const abortIndex int8 = math.MaxInt8 / 2

// Context is the most important part of gin. It allows us to pass variables between middleware,
// manage the flow, validate the JSON of a request and render a JSON response for example.
type Context struct {
        *framework.HadeContainer
        writermem responseWriter
        Request   *http.Request
        Writer    ResponseWriter

        Params   Params
        handlers HandlersChain
        index    int8

        engine *Engine

        // Keys is a key/value pair exclusively for the context of each request.
        Keys map[string]interface{}

        // Errors is a list of errors attached to all the handlers/middlewares who used this context.
        Errors errorMsgs

        // Accepted defines a list of manually accepted formats for content negotiation.
        Accepted []string
}

/************************************/
/********** CONTEXT CREATION ********/
/************************************/

func (c *Context) reset() <span class="cov8" title="1">{
        c.Writer = &amp;c.writermem
        c.Params = c.Params[0:0]
        c.handlers = nil
        c.index = -1
        c.Keys = nil
        c.Errors = c.Errors[0:0]
        c.Accepted = nil
}</span>

// Copy returns a copy of the current context that can be safely used outside the request's scope.
// This has to be used when the context has to be passed to a goroutine.
func (c *Context) Copy() *Context <span class="cov8" title="1">{
        var cp = *c
        cp.writermem.ResponseWriter = nil
        cp.Writer = &amp;cp.writermem
        cp.index = abortIndex
        cp.handlers = nil
        cp.Keys = map[string]interface{}{}
        for k, v := range c.Keys </span><span class="cov8" title="1">{
                cp.Keys[k] = v
        }</span>
        <span class="cov8" title="1">return &amp;cp</span>
}

// HandlerName returns the main handler's name. For example if the handler is "handleGetUsers()",
// this function will return "main.handleGetUsers".
func (c *Context) HandlerName() string <span class="cov0" title="0">{
        return nameOfFunction(c.handlers.Last())
}</span>

// HandlerNames returns a list of all registered handlers for this context in descending order,
// following the semantics of HandlerName()
func (c *Context) HandlerNames() []string <span class="cov8" title="1">{
        hn := make([]string, 0, len(c.handlers))
        for _, val := range c.handlers </span><span class="cov8" title="1">{
                hn = append(hn, nameOfFunction(val))
        }</span>
        <span class="cov8" title="1">return hn</span>
}

// Handler returns the main handler.
func (c *Context) Handler() HandlerFunc <span class="cov8" title="1">{
        return c.handlers.Last()
}</span>

/************************************/
/*********** FLOW CONTROL ***********/
/************************************/

// Next should be used only inside middleware.
// It executes the pending handlers in the chain inside the calling handler.
// See example in GitHub.
func (c *Context) Next() <span class="cov8" title="1">{
        c.index++
        for c.index &lt; int8(len(c.handlers)) </span><span class="cov8" title="1">{
                c.handlers[c.index](c)
                c.index++
        }</span>
}

// IsAborted returns true if the current context was aborted.
func (c *Context) IsAborted() bool <span class="cov8" title="1">{
        return c.index &gt;= abortIndex
}</span>

// Abort prevents pending handlers from being called. Note that this will not stop the current handler.
// Let's say you have an authorization middleware that validates that the current request is authorized.
// If the authorization fails (ex: the password does not match), call Abort to ensure the remaining handlers
// for this request are not called.
func (c *Context) Abort() <span class="cov8" title="1">{
        c.index = abortIndex
}</span>

// AbortWithStatus calls `Abort()` and writes the headers with the specified status code.
// For example, a failed attempt to authenticate a request could use: context.AbortWithStatus(401).
func (c *Context) AbortWithStatus(code int) <span class="cov8" title="1">{
        c.Status(code)
        c.Writer.WriteHeaderNow()
        c.Abort()
}</span>

// AbortWithStatusJSON calls `Abort()` and then `JSON` internally.
// This method stops the chain, writes the status code and return a JSON body.
// It also sets the Content-Type as "application/json".
func (c *Context) AbortWithStatusJSON(code int, jsonObj interface{}) <span class="cov8" title="1">{
        c.Abort()
        c.JSON(code, jsonObj)
}</span>

// AbortWithError calls `AbortWithStatus()` and `Error()` internally.
// This method stops the chain, writes the status code and pushes the specified error to `c.Errors`.
// See Context.Error() for more details.
func (c *Context) AbortWithError(code int, err error) *Error <span class="cov8" title="1">{
        c.AbortWithStatus(code)
        return c.Error(err)
}</span>

/************************************/
/********* ERROR MANAGEMENT *********/
/************************************/

// Error attaches an error to the current context. The error is pushed to a list of errors.
// It's a good idea to call Error for each error that occurred during the resolution of a request.
// A middleware can be used to collect all the errors and push them to a database together,
// print a log, or append it in the HTTP response.
// Error will panic if err is nil.
func (c *Context) Error(err error) *Error <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                panic("err is nil")</span>
        }

        <span class="cov8" title="1">parsedError, ok := err.(*Error)
        if !ok </span><span class="cov8" title="1">{
                parsedError = &amp;Error{
                        Err:  err,
                        Type: ErrorTypePrivate,
                }
        }</span>

        <span class="cov8" title="1">c.Errors = append(c.Errors, parsedError)
        return parsedError</span>
}

/************************************/
/******** METADATA MANAGEMENT********/
/************************************/

// Set is used to store a new key/value pair exclusively for this context.
// It also lazy initializes  c.Keys if it was not used previously.
func (c *Context) Set(key string, value interface{}) <span class="cov8" title="1">{
        if c.Keys == nil </span><span class="cov8" title="1">{
                c.Keys = make(map[string]interface{})
        }</span>
        <span class="cov8" title="1">c.Keys[key] = value</span>
}

// Get returns the value for the given key, ie: (value, true).
// If the value does not exists it returns (nil, false)
func (c *Context) Get(key string) (value interface{}, exists bool) <span class="cov8" title="1">{
        value, exists = c.Keys[key]
        return
}</span>

// MustGet returns the value for the given key if it exists, otherwise it panics.
func (c *Context) MustGet(key string) interface{} <span class="cov8" title="1">{
        if value, exists := c.Get(key); exists </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">panic("Key \"" + key + "\" does not exist")</span>
}

// GetString returns the value associated with the key as a string.
func (c *Context) GetString(key string) (s string) <span class="cov8" title="1">{
        if val, ok := c.Get(key); ok &amp;&amp; val != nil </span><span class="cov8" title="1">{
                s, _ = val.(string)
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetBool returns the value associated with the key as a boolean.
func (c *Context) GetBool(key string) (b bool) <span class="cov8" title="1">{
        if val, ok := c.Get(key); ok &amp;&amp; val != nil </span><span class="cov8" title="1">{
                b, _ = val.(bool)
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetInt returns the value associated with the key as an integer.
func (c *Context) GetInt(key string) (i int) <span class="cov8" title="1">{
        if val, ok := c.Get(key); ok &amp;&amp; val != nil </span><span class="cov8" title="1">{
                i, _ = val.(int)
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetInt64 returns the value associated with the key as an integer.
func (c *Context) GetInt64(key string) (i64 int64) <span class="cov8" title="1">{
        if val, ok := c.Get(key); ok &amp;&amp; val != nil </span><span class="cov8" title="1">{
                i64, _ = val.(int64)
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetFloat64 returns the value associated with the key as a float64.
func (c *Context) GetFloat64(key string) (f64 float64) <span class="cov8" title="1">{
        if val, ok := c.Get(key); ok &amp;&amp; val != nil </span><span class="cov8" title="1">{
                f64, _ = val.(float64)
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetTime returns the value associated with the key as time.
func (c *Context) GetTime(key string) (t time.Time) <span class="cov8" title="1">{
        if val, ok := c.Get(key); ok &amp;&amp; val != nil </span><span class="cov8" title="1">{
                t, _ = val.(time.Time)
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetDuration returns the value associated with the key as a duration.
func (c *Context) GetDuration(key string) (d time.Duration) <span class="cov8" title="1">{
        if val, ok := c.Get(key); ok &amp;&amp; val != nil </span><span class="cov8" title="1">{
                d, _ = val.(time.Duration)
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetStringSlice returns the value associated with the key as a slice of strings.
func (c *Context) GetStringSlice(key string) (ss []string) <span class="cov8" title="1">{
        if val, ok := c.Get(key); ok &amp;&amp; val != nil </span><span class="cov8" title="1">{
                ss, _ = val.([]string)
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetStringMap returns the value associated with the key as a map of interfaces.
func (c *Context) GetStringMap(key string) (sm map[string]interface{}) <span class="cov8" title="1">{
        if val, ok := c.Get(key); ok &amp;&amp; val != nil </span><span class="cov8" title="1">{
                sm, _ = val.(map[string]interface{})
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetStringMapString returns the value associated with the key as a map of strings.
func (c *Context) GetStringMapString(key string) (sms map[string]string) <span class="cov8" title="1">{
        if val, ok := c.Get(key); ok &amp;&amp; val != nil </span><span class="cov8" title="1">{
                sms, _ = val.(map[string]string)
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetStringMapStringSlice returns the value associated with the key as a map to a slice of strings.
func (c *Context) GetStringMapStringSlice(key string) (smss map[string][]string) <span class="cov8" title="1">{
        if val, ok := c.Get(key); ok &amp;&amp; val != nil </span><span class="cov8" title="1">{
                smss, _ = val.(map[string][]string)
        }</span>
        <span class="cov8" title="1">return</span>
}

/************************************/
/************ INPUT DATA ************/
/************************************/

// Param returns the value of the URL param.
// It is a shortcut for c.Params.ByName(key)
//     router.GET("/user/:id", func(c *gin.Context) {
//         // a GET request to /user/john
//         id := c.Param("id") // id == "john"
//     })
func (c *Context) Param(key string) string <span class="cov8" title="1">{
        return c.Params.ByName(key)
}</span>

// Query returns the keyed url query value if it exists,
// otherwise it returns an empty string `("")`.
// It is shortcut for `c.Request.URL.Query().Get(key)`
//     GET /path?id=1234&amp;name=Manu&amp;value=
//            c.Query("id") == "1234"
//            c.Query("name") == "Manu"
//            c.Query("value") == ""
//            c.Query("wtf") == ""
func (c *Context) Query(key string) string <span class="cov8" title="1">{
        value, _ := c.GetQuery(key)
        return value
}</span>

// DefaultQuery returns the keyed url query value if it exists,
// otherwise it returns the specified defaultValue string.
// See: Query() and GetQuery() for further information.
//     GET /?name=Manu&amp;lastname=
//     c.DefaultQuery("name", "unknown") == "Manu"
//     c.DefaultQuery("id", "none") == "none"
//     c.DefaultQuery("lastname", "none") == ""
func (c *Context) DefaultQuery(key, defaultValue string) string <span class="cov8" title="1">{
        if value, ok := c.GetQuery(key); ok </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">return defaultValue</span>
}

// GetQuery is like Query(), it returns the keyed url query value
// if it exists `(value, true)` (even when the value is an empty string),
// otherwise it returns `("", false)`.
// It is shortcut for `c.Request.URL.Query().Get(key)`
//     GET /?name=Manu&amp;lastname=
//     ("Manu", true) == c.GetQuery("name")
//     ("", false) == c.GetQuery("id")
//     ("", true) == c.GetQuery("lastname")
func (c *Context) GetQuery(key string) (string, bool) <span class="cov8" title="1">{
        if values, ok := c.GetQueryArray(key); ok </span><span class="cov8" title="1">{
                return values[0], ok
        }</span>
        <span class="cov8" title="1">return "", false</span>
}

// QueryArray returns a slice of strings for a given query key.
// The length of the slice depends on the number of params with the given key.
func (c *Context) QueryArray(key string) []string <span class="cov8" title="1">{
        values, _ := c.GetQueryArray(key)
        return values
}</span>

// GetQueryArray returns a slice of strings for a given query key, plus
// a boolean value whether at least one value exists for the given key.
func (c *Context) GetQueryArray(key string) ([]string, bool) <span class="cov8" title="1">{
        if values, ok := c.Request.URL.Query()[key]; ok &amp;&amp; len(values) &gt; 0 </span><span class="cov8" title="1">{
                return values, true
        }</span>
        <span class="cov8" title="1">return []string{}, false</span>
}

// QueryMap returns a map for a given query key.
func (c *Context) QueryMap(key string) map[string]string <span class="cov8" title="1">{
        dicts, _ := c.GetQueryMap(key)
        return dicts
}</span>

// GetQueryMap returns a map for a given query key, plus a boolean value
// whether at least one value exists for the given key.
func (c *Context) GetQueryMap(key string) (map[string]string, bool) <span class="cov8" title="1">{
        return c.get(c.Request.URL.Query(), key)
}</span>

// PostForm returns the specified key from a POST urlencoded form or multipart form
// when it exists, otherwise it returns an empty string `("")`.
func (c *Context) PostForm(key string) string <span class="cov8" title="1">{
        value, _ := c.GetPostForm(key)
        return value
}</span>

// DefaultPostForm returns the specified key from a POST urlencoded form or multipart form
// when it exists, otherwise it returns the specified defaultValue string.
// See: PostForm() and GetPostForm() for further information.
func (c *Context) DefaultPostForm(key, defaultValue string) string <span class="cov8" title="1">{
        if value, ok := c.GetPostForm(key); ok </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">return defaultValue</span>
}

// GetPostForm is like PostForm(key). It returns the specified key from a POST urlencoded
// form or multipart form when it exists `(value, true)` (even when the value is an empty string),
// otherwise it returns ("", false).
// For example, during a PATCH request to update the user's email:
//     email=mail@example.com  --&gt;  ("mail@example.com", true) := GetPostForm("email") // set email to "mail@example.com"
//            email=                  --&gt;  ("", true) := GetPostForm("email") // set email to ""
//                             --&gt;  ("", false) := GetPostForm("email") // do nothing with email
func (c *Context) GetPostForm(key string) (string, bool) <span class="cov8" title="1">{
        if values, ok := c.GetPostFormArray(key); ok </span><span class="cov8" title="1">{
                return values[0], ok
        }</span>
        <span class="cov8" title="1">return "", false</span>
}

// PostFormArray returns a slice of strings for a given form key.
// The length of the slice depends on the number of params with the given key.
func (c *Context) PostFormArray(key string) []string <span class="cov8" title="1">{
        values, _ := c.GetPostFormArray(key)
        return values
}</span>

// GetPostFormArray returns a slice of strings for a given form key, plus
// a boolean value whether at least one value exists for the given key.
func (c *Context) GetPostFormArray(key string) ([]string, bool) <span class="cov8" title="1">{
        req := c.Request
        if err := req.ParseMultipartForm(c.engine.MaxMultipartMemory); err != nil </span><span class="cov8" title="1">{
                if err != http.ErrNotMultipart </span><span class="cov0" title="0">{
                        debugPrint("error on parse multipart form array: %v", err)
                }</span>
        }
        <span class="cov8" title="1">if values := req.PostForm[key]; len(values) &gt; 0 </span><span class="cov8" title="1">{
                return values, true
        }</span>
        <span class="cov8" title="1">return []string{}, false</span>
}

// PostFormMap returns a map for a given form key.
func (c *Context) PostFormMap(key string) map[string]string <span class="cov8" title="1">{
        dicts, _ := c.GetPostFormMap(key)
        return dicts
}</span>

// GetPostFormMap returns a map for a given form key, plus a boolean value
// whether at least one value exists for the given key.
func (c *Context) GetPostFormMap(key string) (map[string]string, bool) <span class="cov8" title="1">{
        req := c.Request
        if err := req.ParseMultipartForm(c.engine.MaxMultipartMemory); err != nil </span><span class="cov0" title="0">{
                if err != http.ErrNotMultipart </span><span class="cov0" title="0">{
                        debugPrint("error on parse multipart form map: %v", err)
                }</span>
        }
        <span class="cov8" title="1">return c.get(req.PostForm, key)</span>
}

// get is an internal method and returns a map which satisfy conditions.
func (c *Context) get(m map[string][]string, key string) (map[string]string, bool) <span class="cov8" title="1">{
        dicts := make(map[string]string)
        exist := false
        for k, v := range m </span><span class="cov8" title="1">{
                if i := strings.IndexByte(k, '['); i &gt;= 1 &amp;&amp; k[0:i] == key </span><span class="cov8" title="1">{
                        if j := strings.IndexByte(k[i+1:], ']'); j &gt;= 1 </span><span class="cov8" title="1">{
                                exist = true
                                dicts[k[i+1:][:j]] = v[0]
                        }</span>
                }
        }
        <span class="cov8" title="1">return dicts, exist</span>
}

// FormFile returns the first file for the provided form key.
func (c *Context) FormFile(name string) (*multipart.FileHeader, error) <span class="cov8" title="1">{
        if c.Request.MultipartForm == nil </span><span class="cov8" title="1">{
                if err := c.Request.ParseMultipartForm(c.engine.MaxMultipartMemory); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">_, fh, err := c.Request.FormFile(name)
        return fh, err</span>
}

// MultipartForm is the parsed multipart form, including file uploads.
func (c *Context) MultipartForm() (*multipart.Form, error) <span class="cov8" title="1">{
        err := c.Request.ParseMultipartForm(c.engine.MaxMultipartMemory)
        return c.Request.MultipartForm, err
}</span>

// SaveUploadedFile uploads the form file to specific dst.
func (c *Context) SaveUploadedFile(file *multipart.FileHeader, dst string) error <span class="cov8" title="1">{
        src, err := file.Open()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer src.Close()

        out, err := os.Create(dst)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer out.Close()

        _, err = io.Copy(out, src)
        return err</span>
}

// Bind checks the Content-Type to select a binding engine automatically,
// Depending the "Content-Type" header different bindings are used:
//     "application/json" --&gt; JSON binding
//     "application/xml"  --&gt; XML binding
// otherwise --&gt; returns an error.
// It parses the request's body as JSON if Content-Type == "application/json" using JSON or XML as a JSON input.
// It decodes the json payload into the struct specified as a pointer.
// It writes a 400 error and sets Content-Type header "text/plain" in the response if input is not valid.
func (c *Context) Bind(obj interface{}) error <span class="cov8" title="1">{
        b := binding.Default(c.Request.Method, c.ContentType())
        return c.MustBindWith(obj, b)
}</span>

// BindJSON is a shortcut for c.MustBindWith(obj, binding.JSON).
func (c *Context) BindJSON(obj interface{}) error <span class="cov8" title="1">{
        return c.MustBindWith(obj, binding.JSON)
}</span>

// BindXML is a shortcut for c.MustBindWith(obj, binding.BindXML).
func (c *Context) BindXML(obj interface{}) error <span class="cov8" title="1">{
        return c.MustBindWith(obj, binding.XML)
}</span>

// BindQuery is a shortcut for c.MustBindWith(obj, binding.Query).
func (c *Context) BindQuery(obj interface{}) error <span class="cov8" title="1">{
        return c.MustBindWith(obj, binding.Query)
}</span>

// BindYAML is a shortcut for c.MustBindWith(obj, binding.YAML).
func (c *Context) BindYAML(obj interface{}) error <span class="cov8" title="1">{
        return c.MustBindWith(obj, binding.YAML)
}</span>

// BindUri binds the passed struct pointer using binding.Uri.
// It will abort the request with HTTP 400 if any error occurs.
func (c *Context) BindUri(obj interface{}) error <span class="cov8" title="1">{
        if err := c.ShouldBindUri(obj); err != nil </span><span class="cov8" title="1">{
                c.AbortWithError(http.StatusBadRequest, err).SetType(ErrorTypeBind) // nolint: errcheck
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// MustBindWith binds the passed struct pointer using the specified binding engine.
// It will abort the request with HTTP 400 if any error occurs.
// See the binding package.
func (c *Context) MustBindWith(obj interface{}, b binding.Binding) error <span class="cov8" title="1">{
        if err := c.ShouldBindWith(obj, b); err != nil </span><span class="cov8" title="1">{
                c.AbortWithError(http.StatusBadRequest, err).SetType(ErrorTypeBind) // nolint: errcheck
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ShouldBind checks the Content-Type to select a binding engine automatically,
// Depending the "Content-Type" header different bindings are used:
//     "application/json" --&gt; JSON binding
//     "application/xml"  --&gt; XML binding
// otherwise --&gt; returns an error
// It parses the request's body as JSON if Content-Type == "application/json" using JSON or XML as a JSON input.
// It decodes the json payload into the struct specified as a pointer.
// Like c.Bind() but this method does not set the response status code to 400 and abort if the json is not valid.
func (c *Context) ShouldBind(obj interface{}) error <span class="cov8" title="1">{
        b := binding.Default(c.Request.Method, c.ContentType())
        return c.ShouldBindWith(obj, b)
}</span>

// ShouldBindJSON is a shortcut for c.ShouldBindWith(obj, binding.JSON).
func (c *Context) ShouldBindJSON(obj interface{}) error <span class="cov8" title="1">{
        return c.ShouldBindWith(obj, binding.JSON)
}</span>

// ShouldBindXML is a shortcut for c.ShouldBindWith(obj, binding.XML).
func (c *Context) ShouldBindXML(obj interface{}) error <span class="cov8" title="1">{
        return c.ShouldBindWith(obj, binding.XML)
}</span>

// ShouldBindQuery is a shortcut for c.ShouldBindWith(obj, binding.Query).
func (c *Context) ShouldBindQuery(obj interface{}) error <span class="cov8" title="1">{
        return c.ShouldBindWith(obj, binding.Query)
}</span>

// ShouldBindYAML is a shortcut for c.ShouldBindWith(obj, binding.YAML).
func (c *Context) ShouldBindYAML(obj interface{}) error <span class="cov8" title="1">{
        return c.ShouldBindWith(obj, binding.YAML)
}</span>

// ShouldBindUri binds the passed struct pointer using the specified binding engine.
func (c *Context) ShouldBindUri(obj interface{}) error <span class="cov8" title="1">{
        m := make(map[string][]string)
        for _, v := range c.Params </span><span class="cov8" title="1">{
                m[v.Key] = []string{v.Value}
        }</span>
        <span class="cov8" title="1">return binding.Uri.BindUri(m, obj)</span>
}

// ShouldBindWith binds the passed struct pointer using the specified binding engine.
// See the binding package.
func (c *Context) ShouldBindWith(obj interface{}, b binding.Binding) error <span class="cov8" title="1">{
        return b.Bind(c.Request, obj)
}</span>

// ShouldBindBodyWith is similar with ShouldBindWith, but it stores the request
// body into the context, and reuse when it is called again.
//
// NOTE: This method reads the body before binding. So you should use
// ShouldBindWith for better performance if you need to call only once.
func (c *Context) ShouldBindBodyWith(obj interface{}, bb binding.BindingBody) (err error) <span class="cov8" title="1">{
        var body []byte
        if cb, ok := c.Get(BodyBytesKey); ok </span><span class="cov8" title="1">{
                if cbb, ok := cb.([]byte); ok </span><span class="cov8" title="1">{
                        body = cbb
                }</span>
        }
        <span class="cov8" title="1">if body == nil </span><span class="cov8" title="1">{
                body, err = ioutil.ReadAll(c.Request.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">c.Set(BodyBytesKey, body)</span>
        }
        <span class="cov8" title="1">return bb.BindBody(body, obj)</span>
}

// ClientIP implements a best effort algorithm to return the real client IP, it parses
// X-Real-IP and X-Forwarded-For in order to work properly with reverse-proxies such us: nginx or haproxy.
// Use X-Forwarded-For before X-Real-Ip as nginx uses X-Real-Ip with the proxy's IP.
func (c *Context) ClientIP() string <span class="cov8" title="1">{
        if c.engine.ForwardedByClientIP </span><span class="cov8" title="1">{
                clientIP := c.requestHeader("X-Forwarded-For")
                clientIP = strings.TrimSpace(strings.Split(clientIP, ",")[0])
                if clientIP == "" </span><span class="cov8" title="1">{
                        clientIP = strings.TrimSpace(c.requestHeader("X-Real-Ip"))
                }</span>
                <span class="cov8" title="1">if clientIP != "" </span><span class="cov8" title="1">{
                        return clientIP
                }</span>
        }

        <span class="cov8" title="1">if c.engine.AppEngine </span><span class="cov8" title="1">{
                if addr := c.requestHeader("X-Appengine-Remote-Addr"); addr != "" </span><span class="cov8" title="1">{
                        return addr
                }</span>
        }

        <span class="cov8" title="1">if ip, _, err := net.SplitHostPort(strings.TrimSpace(c.Request.RemoteAddr)); err == nil </span><span class="cov8" title="1">{
                return ip
        }</span>

        <span class="cov8" title="1">return ""</span>
}

// ContentType returns the Content-Type header of the request.
func (c *Context) ContentType() string <span class="cov8" title="1">{
        return filterFlags(c.requestHeader("Content-Type"))
}</span>

// IsWebsocket returns true if the request headers indicate that a websocket
// handshake is being initiated by the client.
func (c *Context) IsWebsocket() bool <span class="cov8" title="1">{
        if strings.Contains(strings.ToLower(c.requestHeader("Connection")), "upgrade") &amp;&amp;
                strings.ToLower(c.requestHeader("Upgrade")) == "websocket" </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func (c *Context) requestHeader(key string) string <span class="cov8" title="1">{
        return c.Request.Header.Get(key)
}</span>

/************************************/
/******** RESPONSE RENDERING ********/
/************************************/

// bodyAllowedForStatus is a copy of http.bodyAllowedForStatus non-exported function.
func bodyAllowedForStatus(status int) bool <span class="cov8" title="1">{
        switch </span>{
        case status &gt;= 100 &amp;&amp; status &lt;= 199:<span class="cov8" title="1">
                return false</span>
        case status == http.StatusNoContent:<span class="cov8" title="1">
                return false</span>
        case status == http.StatusNotModified:<span class="cov8" title="1">
                return false</span>
        }
        <span class="cov8" title="1">return true</span>
}

// Status sets the HTTP response code.
func (c *Context) Status(code int) <span class="cov8" title="1">{
        c.writermem.WriteHeader(code)
}</span>

// Header is a intelligent shortcut for c.Writer.Header().Set(key, value).
// It writes a header in the response.
// If value == "", this method removes the header `c.Writer.Header().Del(key)`
func (c *Context) Header(key, value string) <span class="cov8" title="1">{
        if value == "" </span><span class="cov8" title="1">{
                c.Writer.Header().Del(key)
                return
        }</span>
        <span class="cov8" title="1">c.Writer.Header().Set(key, value)</span>
}

// GetHeader returns value from request headers.
func (c *Context) GetHeader(key string) string <span class="cov8" title="1">{
        return c.requestHeader(key)
}</span>

// GetRawData return stream data.
func (c *Context) GetRawData() ([]byte, error) <span class="cov8" title="1">{
        return ioutil.ReadAll(c.Request.Body)
}</span>

// SetCookie adds a Set-Cookie header to the ResponseWriter's headers.
// The provided cookie must have a valid Name. Invalid cookies may be
// silently dropped.
func (c *Context) SetCookie(name, value string, maxAge int, path, domain string, secure, httpOnly bool) <span class="cov8" title="1">{
        if path == "" </span><span class="cov8" title="1">{
                path = "/"
        }</span>
        <span class="cov8" title="1">http.SetCookie(c.Writer, &amp;http.Cookie{
                Name:     name,
                Value:    url.QueryEscape(value),
                MaxAge:   maxAge,
                Path:     path,
                Domain:   domain,
                Secure:   secure,
                HttpOnly: httpOnly,
        })</span>
}

// Cookie returns the named cookie provided in the request or
// ErrNoCookie if not found. And return the named cookie is unescaped.
// If multiple cookies match the given name, only one cookie will
// be returned.
func (c *Context) Cookie(name string) (string, error) <span class="cov8" title="1">{
        cookie, err := c.Request.Cookie(name)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">val, _ := url.QueryUnescape(cookie.Value)
        return val, nil</span>
}

// Render writes the response headers and calls render.Render to render data.
func (c *Context) Render(code int, r render.Render) <span class="cov8" title="1">{
        c.Status(code)

        if !bodyAllowedForStatus(code) </span><span class="cov8" title="1">{
                r.WriteContentType(c.Writer)
                c.Writer.WriteHeaderNow()
                return
        }</span>

        <span class="cov8" title="1">if err := r.Render(c.Writer); err != nil </span><span class="cov8" title="1">{
                panic(err)</span>
        }
}

// HTML renders the HTTP template specified by its file name.
// It also updates the HTTP code and sets the Content-Type as "text/html".
// See http://golang.org/doc/articles/wiki/
func (c *Context) HTML(code int, name string, obj interface{}) <span class="cov8" title="1">{
        instance := c.engine.HTMLRender.Instance(name, obj)
        c.Render(code, instance)
}</span>

// IndentedJSON serializes the given struct as pretty JSON (indented + endlines) into the response body.
// It also sets the Content-Type as "application/json".
// WARNING: we recommend to use this only for development purposes since printing pretty JSON is
// more CPU and bandwidth consuming. Use Context.JSON() instead.
func (c *Context) IndentedJSON(code int, obj interface{}) <span class="cov8" title="1">{
        c.Render(code, render.IndentedJSON{Data: obj})
}</span>

// SecureJSON serializes the given struct as Secure JSON into the response body.
// Default prepends "while(1)," to response body if the given struct is array values.
// It also sets the Content-Type as "application/json".
func (c *Context) SecureJSON(code int, obj interface{}) <span class="cov8" title="1">{
        c.Render(code, render.SecureJSON{Prefix: c.engine.secureJsonPrefix, Data: obj})
}</span>

// JSONP serializes the given struct as JSON into the response body.
// It add padding to response body to request data from a server residing in a different domain than the client.
// It also sets the Content-Type as "application/javascript".
func (c *Context) JSONP(code int, obj interface{}) <span class="cov8" title="1">{
        callback := c.DefaultQuery("callback", "")
        if callback == "" </span><span class="cov8" title="1">{
                c.Render(code, render.JSON{Data: obj})
                return
        }</span>
        <span class="cov8" title="1">c.Render(code, render.JsonpJSON{Callback: callback, Data: obj})</span>
}

// JSON serializes the given struct as JSON into the response body.
// It also sets the Content-Type as "application/json".
func (c *Context) JSON(code int, obj interface{}) <span class="cov8" title="1">{
        c.Render(code, render.JSON{Data: obj})
}</span>

// AsciiJSON serializes the given struct as JSON into the response body with unicode to ASCII string.
// It also sets the Content-Type as "application/json".
func (c *Context) AsciiJSON(code int, obj interface{}) <span class="cov8" title="1">{
        c.Render(code, render.AsciiJSON{Data: obj})
}</span>

// PureJSON serializes the given struct as JSON into the response body.
// PureJSON, unlike JSON, does not replace special html characters with their unicode entities.
func (c *Context) PureJSON(code int, obj interface{}) <span class="cov8" title="1">{
        c.Render(code, render.PureJSON{Data: obj})
}</span>

// XML serializes the given struct as XML into the response body.
// It also sets the Content-Type as "application/xml".
func (c *Context) XML(code int, obj interface{}) <span class="cov8" title="1">{
        c.Render(code, render.XML{Data: obj})
}</span>

// YAML serializes the given struct as YAML into the response body.
func (c *Context) YAML(code int, obj interface{}) <span class="cov8" title="1">{
        c.Render(code, render.YAML{Data: obj})
}</span>

// ProtoBuf serializes the given struct as ProtoBuf into the response body.
func (c *Context) ProtoBuf(code int, obj interface{}) <span class="cov8" title="1">{
        c.Render(code, render.ProtoBuf{Data: obj})
}</span>

// String writes the given string into the response body.
func (c *Context) String(code int, format string, values ...interface{}) <span class="cov8" title="1">{
        c.Render(code, render.String{Format: format, Data: values})
}</span>

// Redirect returns a HTTP redirect to the specific location.
func (c *Context) Redirect(code int, location string) <span class="cov8" title="1">{
        c.Render(-1, render.Redirect{
                Code:     code,
                Location: location,
                Request:  c.Request,
        })
}</span>

// Data writes some data into the body stream and updates the HTTP code.
func (c *Context) Data(code int, contentType string, data []byte) <span class="cov8" title="1">{
        c.Render(code, render.Data{
                ContentType: contentType,
                Data:        data,
        })
}</span>

// DataFromReader writes the specified reader into the body stream and updates the HTTP code.
func (c *Context) DataFromReader(code int, contentLength int64, contentType string, reader io.Reader, extraHeaders map[string]string) <span class="cov8" title="1">{
        c.Render(code, render.Reader{
                Headers:       extraHeaders,
                ContentType:   contentType,
                ContentLength: contentLength,
                Reader:        reader,
        })
}</span>

// File writes the specified file into the body stream in a efficient way.
func (c *Context) File(filepath string) <span class="cov8" title="1">{
        http.ServeFile(c.Writer, c.Request, filepath)
}</span>

// FileAttachment writes the specified file into the body stream in an efficient way
// On the client side, the file will typically be downloaded with the given filename
func (c *Context) FileAttachment(filepath, filename string) <span class="cov8" title="1">{
        c.Writer.Header().Set("content-disposition", fmt.Sprintf("attachment; filename=\"%s\"", filename))
        http.ServeFile(c.Writer, c.Request, filepath)
}</span>

// SSEvent writes a Server-Sent Event into the body stream.
func (c *Context) SSEvent(name string, message interface{}) <span class="cov8" title="1">{
        c.Render(-1, sse.Event{
                Event: name,
                Data:  message,
        })
}</span>

// Stream sends a streaming response and returns a boolean
// indicates "Is client disconnected in middle of stream"
func (c *Context) Stream(step func(w io.Writer) bool) bool <span class="cov8" title="1">{
        w := c.Writer
        clientGone := w.CloseNotify()
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-clientGone:<span class="cov8" title="1">
                        return true</span>
                default:<span class="cov8" title="1">
                        keepOpen := step(w)
                        w.Flush()
                        if !keepOpen </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
        }
}

/************************************/
/******** CONTENT NEGOTIATION *******/
/************************************/

// Negotiate contains all negotiations data.
type Negotiate struct {
        Offered  []string
        HTMLName string
        HTMLData interface{}
        JSONData interface{}
        XMLData  interface{}
        Data     interface{}
}

// Negotiate calls different Render according acceptable Accept format.
func (c *Context) Negotiate(code int, config Negotiate) <span class="cov8" title="1">{
        switch c.NegotiateFormat(config.Offered...) </span>{
        case binding.MIMEJSON:<span class="cov8" title="1">
                data := chooseData(config.JSONData, config.Data)
                c.JSON(code, data)</span>

        case binding.MIMEHTML:<span class="cov8" title="1">
                data := chooseData(config.HTMLData, config.Data)
                c.HTML(code, config.HTMLName, data)</span>

        case binding.MIMEXML:<span class="cov8" title="1">
                data := chooseData(config.XMLData, config.Data)
                c.XML(code, data)</span>

        default:<span class="cov8" title="1">
                c.AbortWithError(http.StatusNotAcceptable, errors.New("the accepted formats are not offered by the server"))</span> // nolint: errcheck
        }
}

// NegotiateFormat returns an acceptable Accept format.
func (c *Context) NegotiateFormat(offered ...string) string <span class="cov8" title="1">{
        assert1(len(offered) &gt; 0, "you must provide at least one offer")

        if c.Accepted == nil </span><span class="cov8" title="1">{
                c.Accepted = parseAccept(c.requestHeader("Accept"))
        }</span>
        <span class="cov8" title="1">if len(c.Accepted) == 0 </span><span class="cov8" title="1">{
                return offered[0]
        }</span>
        <span class="cov8" title="1">for _, accepted := range c.Accepted </span><span class="cov8" title="1">{
                for _, offert := range offered </span><span class="cov8" title="1">{
                        // According to RFC 2616 and RFC 2396, non-ASCII characters are not allowed in headers,
                        // therefore we can just iterate over the string without casting it into []rune
                        i := 0
                        for ; i &lt; len(accepted); i++ </span><span class="cov8" title="1">{
                                if accepted[i] == '*' || offert[i] == '*' </span><span class="cov8" title="1">{
                                        return offert
                                }</span>
                                <span class="cov8" title="1">if accepted[i] != offert[i] </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if i == len(accepted) </span><span class="cov8" title="1">{
                                return offert
                        }</span>
                }
        }
        <span class="cov8" title="1">return ""</span>
}

// SetAccepted sets Accept header data.
func (c *Context) SetAccepted(formats ...string) <span class="cov8" title="1">{
        c.Accepted = formats
}</span>

/************************************/
/***** GOLANG.ORG/X/NET/CONTEXT *****/
/************************************/

// Deadline returns the time when work done on behalf of this context
// should be canceled. Deadline returns ok==false when no deadline is
// set. Successive calls to Deadline return the same results.
func (c *Context) Deadline() (deadline time.Time, ok bool) <span class="cov8" title="1">{
        return
}</span>

// Done returns a channel that's closed when work done on behalf of this
// context should be canceled. Done may return nil if this context can
// never be canceled. Successive calls to Done return the same value.
func (c *Context) Done() &lt;-chan struct{} <span class="cov8" title="1">{
        return nil
}</span>

// Err returns a non-nil error value after Done is closed,
// successive calls to Err return the same error.
// If Done is not yet closed, Err returns nil.
// If Done is closed, Err returns a non-nil error explaining why:
// Canceled if the context was canceled
// or DeadlineExceeded if the context's deadline passed.
func (c *Context) Err() error <span class="cov8" title="1">{
        return nil
}</span>

// Value returns the value associated with this context for key, or nil
// if no value is associated with key. Successive calls to Value with
// the same key returns the same result.
func (c *Context) Value(key interface{}) interface{} <span class="cov8" title="1">{
        if key == 0 </span><span class="cov8" title="1">{
                return c.Request
        }</span>
        <span class="cov8" title="1">if keyAsString, ok := key.(string); ok </span><span class="cov8" title="1">{
                val, _ := c.Get(keyAsString)
                return val
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Copyright 2014 Manu Martinez-Almeida.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package gin

import (
        "bytes"
        "fmt"
        "html/template"
        "os"
        "runtime"
        "strconv"
        "strings"
)

const ginSupportMinGoVer = 8

// IsDebugging returns true if the framework is running in debug mode.
// Use SetMode(gin.ReleaseMode) to disable debug mode.
func IsDebugging() bool <span class="cov8" title="1">{
        return ginMode == debugCode
}</span>

// DebugPrintRouteFunc indicates debug log output format.
var DebugPrintRouteFunc func(httpMethod, absolutePath, handlerName string, nuHandlers int)

func debugPrintRoute(httpMethod, absolutePath string, handlers HandlersChain) <span class="cov8" title="1">{
        if IsDebugging() </span><span class="cov8" title="1">{
                nuHandlers := len(handlers)
                handlerName := nameOfFunction(handlers.Last())
                if DebugPrintRouteFunc == nil </span><span class="cov8" title="1">{
                        debugPrint("%-6s %-25s --&gt; %s (%d handlers)\n", httpMethod, absolutePath, handlerName, nuHandlers)
                }</span> else<span class="cov0" title="0"> {
                        DebugPrintRouteFunc(httpMethod, absolutePath, handlerName, nuHandlers)
                }</span>
        }
}

func debugPrintLoadTemplate(tmpl *template.Template) <span class="cov8" title="1">{
        if IsDebugging() </span><span class="cov8" title="1">{
                var buf bytes.Buffer
                for _, tmpl := range tmpl.Templates() </span><span class="cov8" title="1">{
                        buf.WriteString("\t- ")
                        buf.WriteString(tmpl.Name())
                        buf.WriteString("\n")
                }</span>
                <span class="cov8" title="1">debugPrint("Loaded HTML Templates (%d): \n%s\n", len(tmpl.Templates()), buf.String())</span>
        }
}

func debugPrint(format string, values ...interface{}) <span class="cov8" title="1">{
        if IsDebugging() </span><span class="cov8" title="1">{
                if !strings.HasSuffix(format, "\n") </span><span class="cov8" title="1">{
                        format += "\n"
                }</span>
                <span class="cov8" title="1">fmt.Fprintf(os.Stderr, "[GIN-debug] "+format, values...)</span>
        }
}

func getMinVer(v string) (uint64, error) <span class="cov8" title="1">{
        first := strings.IndexByte(v, '.')
        last := strings.LastIndexByte(v, '.')
        if first == last </span><span class="cov8" title="1">{
                return strconv.ParseUint(v[first+1:], 10, 64)
        }</span>
        <span class="cov8" title="1">return strconv.ParseUint(v[first+1:last], 10, 64)</span>
}

func debugPrintWARNINGDefault() <span class="cov8" title="1">{
        if v, e := getMinVer(runtime.Version()); e == nil &amp;&amp; v &lt;= ginSupportMinGoVer </span><span class="cov0" title="0">{
                debugPrint(`[WARNING] Now Gin requires Go 1.8 or later and Go 1.9 will be required soon.

`)
        }</span>
        <span class="cov8" title="1">debugPrint(`[WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.

`)</span>
}

func debugPrintWARNINGNew() <span class="cov8" title="1">{
        debugPrint(`[WARNING] Running in "debug" mode. Switch to "release" mode in production.
 - using env:        export GIN_MODE=release
 - using code:        gin.SetMode(gin.ReleaseMode)

`)
}</span>

func debugPrintWARNINGSetHTMLTemplate() <span class="cov8" title="1">{
        debugPrint(`[WARNING] Since SetHTMLTemplate() is NOT thread-safe. It should only be called
at initialization. ie. before any route is registered or the router is listening in a socket:

        router := gin.Default()
        router.SetHTMLTemplate(template) // &lt;&lt; good place

`)
}</span>

func debugPrintError(err error) <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                debugPrint("[ERROR] %v\n", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Copyright 2014 Manu Martinez-Almeida.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package gin

import (
        "log"

        "github.com/jianfengye/hade/gin/binding"
)

// BindWith binds the passed struct pointer using the specified binding engine.
// See the binding package.
func (c *Context) BindWith(obj interface{}, b binding.Binding) error <span class="cov8" title="1">{
        log.Println(`BindWith(\"interface{}, binding.Binding\") error is going to
        be deprecated, please check issue #662 and either use MustBindWith() if you
        want HTTP 400 to be automatically returned if any error occur, or use
        ShouldBindWith() if you need to manage the error.`)
        return c.MustBindWith(obj, b)
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">// Copyright 2014 Manu Martinez-Almeida.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package gin

import (
        "bytes"
        "fmt"
        "reflect"

        "github.com/jianfengye/hade/gin/internal/json"
)

// ErrorType is an unsigned 64-bit error code as defined in the gin spec.
type ErrorType uint64

const (
        // ErrorTypeBind is used when Context.Bind() fails.
        ErrorTypeBind ErrorType = 1 &lt;&lt; 63
        // ErrorTypeRender is used when Context.Render() fails.
        ErrorTypeRender ErrorType = 1 &lt;&lt; 62
        // ErrorTypePrivate indicates a private error.
        ErrorTypePrivate ErrorType = 1 &lt;&lt; 0
        // ErrorTypePublic indicates a public error.
        ErrorTypePublic ErrorType = 1 &lt;&lt; 1
        // ErrorTypeAny indicates any other error.
        ErrorTypeAny ErrorType = 1&lt;&lt;64 - 1
        // ErrorTypeNu indicates any other error.
        ErrorTypeNu = 2
)

// Error represents a error's specification.
type Error struct {
        Err  error
        Type ErrorType
        Meta interface{}
}

type errorMsgs []*Error

var _ error = &amp;Error{}

// SetType sets the error's type.
func (msg *Error) SetType(flags ErrorType) *Error <span class="cov8" title="1">{
        msg.Type = flags
        return msg
}</span>

// SetMeta sets the error's meta data.
func (msg *Error) SetMeta(data interface{}) *Error <span class="cov8" title="1">{
        msg.Meta = data
        return msg
}</span>

// JSON creates a properly formatted JSON
func (msg *Error) JSON() interface{} <span class="cov8" title="1">{
        json := H{}
        if msg.Meta != nil </span><span class="cov8" title="1">{
                value := reflect.ValueOf(msg.Meta)
                switch value.Kind() </span>{
                case reflect.Struct:<span class="cov8" title="1">
                        return msg.Meta</span>
                case reflect.Map:<span class="cov8" title="1">
                        for _, key := range value.MapKeys() </span><span class="cov8" title="1">{
                                json[key.String()] = value.MapIndex(key).Interface()
                        }</span>
                default:<span class="cov8" title="1">
                        json["meta"] = msg.Meta</span>
                }
        }
        <span class="cov8" title="1">if _, ok := json["error"]; !ok </span><span class="cov8" title="1">{
                json["error"] = msg.Error()
        }</span>
        <span class="cov8" title="1">return json</span>
}

// MarshalJSON implements the json.Marshaller interface.
func (msg *Error) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(msg.JSON())
}</span>

// Error implements the error interface.
func (msg Error) Error() string <span class="cov8" title="1">{
        return msg.Err.Error()
}</span>

// IsType judges one error.
func (msg *Error) IsType(flags ErrorType) bool <span class="cov8" title="1">{
        return (msg.Type &amp; flags) &gt; 0
}</span>

// ByType returns a readonly copy filtered the byte.
// ie ByType(gin.ErrorTypePublic) returns a slice of errors with type=ErrorTypePublic.
func (a errorMsgs) ByType(typ ErrorType) errorMsgs <span class="cov8" title="1">{
        if len(a) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if typ == ErrorTypeAny </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">var result errorMsgs
        for _, msg := range a </span><span class="cov8" title="1">{
                if msg.IsType(typ) </span><span class="cov8" title="1">{
                        result = append(result, msg)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// Last returns the last error in the slice. It returns nil if the array is empty.
// Shortcut for errors[len(errors)-1].
func (a errorMsgs) Last() *Error <span class="cov8" title="1">{
        if length := len(a); length &gt; 0 </span><span class="cov8" title="1">{
                return a[length-1]
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Errors returns an array will all the error messages.
// Example:
//                 c.Error(errors.New("first"))
//                 c.Error(errors.New("second"))
//                 c.Error(errors.New("third"))
//                 c.Errors.Errors() // == []string{"first", "second", "third"}
func (a errorMsgs) Errors() []string <span class="cov8" title="1">{
        if len(a) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">errorStrings := make([]string, len(a))
        for i, err := range a </span><span class="cov8" title="1">{
                errorStrings[i] = err.Error()
        }</span>
        <span class="cov8" title="1">return errorStrings</span>
}

func (a errorMsgs) JSON() interface{} <span class="cov8" title="1">{
        switch len(a) </span>{
        case 0:<span class="cov8" title="1">
                return nil</span>
        case 1:<span class="cov8" title="1">
                return a.Last().JSON()</span>
        default:<span class="cov8" title="1">
                json := make([]interface{}, len(a))
                for i, err := range a </span><span class="cov8" title="1">{
                        json[i] = err.JSON()
                }</span>
                <span class="cov8" title="1">return json</span>
        }
}

// MarshalJSON implements the json.Marshaller interface.
func (a errorMsgs) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(a.JSON())
}</span>

func (a errorMsgs) String() string <span class="cov8" title="1">{
        if len(a) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">var buffer bytes.Buffer
        for i, msg := range a </span><span class="cov8" title="1">{
                fmt.Fprintf(&amp;buffer, "Error #%02d: %s\n", i+1, msg.Err)
                if msg.Meta != nil </span><span class="cov8" title="1">{
                        fmt.Fprintf(&amp;buffer, "     Meta: %v\n", msg.Meta)
                }</span>
        }
        <span class="cov8" title="1">return buffer.String()</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">// Copyright 2017 Manu Martinez-Almeida.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package gin

import (
        "net/http"
        "os"
)

type onlyfilesFS struct {
        fs http.FileSystem
}

type neuteredReaddirFile struct {
        http.File
}

// Dir returns a http.Filesystem that can be used by http.FileServer(). It is used internally
// in router.Static().
// if listDirectory == true, then it works the same as http.Dir() otherwise it returns
// a filesystem that prevents http.FileServer() to list the directory files.
func Dir(root string, listDirectory bool) http.FileSystem <span class="cov8" title="1">{
        fs := http.Dir(root)
        if listDirectory </span><span class="cov8" title="1">{
                return fs
        }</span>
        <span class="cov8" title="1">return &amp;onlyfilesFS{fs}</span>
}

// Open conforms to http.Filesystem.
func (fs onlyfilesFS) Open(name string) (http.File, error) <span class="cov8" title="1">{
        f, err := fs.fs.Open(name)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return neuteredReaddirFile{f}, nil</span>
}

// Readdir overrides the http.File default implementation.
func (f neuteredReaddirFile) Readdir(count int) ([]os.FileInfo, error) <span class="cov8" title="1">{
        // this disables directory listing
        return nil, nil
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">// Copyright 2014 Manu Martinez-Almeida.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package gin

import (
        "fmt"
        "html/template"
        "net"
        "net/http"
        "os"
        "path"
        "sync"

        "github.com/jianfengye/hade/framework"
        "github.com/jianfengye/hade/gin/render"
)

const defaultMultipartMemory = 32 &lt;&lt; 20 // 32 MB

var (
        default404Body   = []byte("404 page not found")
        default405Body   = []byte("405 method not allowed")
        defaultAppEngine bool
)

// HandlerFunc defines the handler used by gin middleware as return value.
type HandlerFunc func(*Context)

// HandlersChain defines a HandlerFunc array.
type HandlersChain []HandlerFunc

// Last returns the last handler in the chain. ie. the last handler is the main own.
func (c HandlersChain) Last() HandlerFunc <span class="cov8" title="1">{
        if length := len(c); length &gt; 0 </span><span class="cov8" title="1">{
                return c[length-1]
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// RouteInfo represents a request route's specification which contains method and path and its handler.
type RouteInfo struct {
        Method      string
        Path        string
        Handler     string
        HandlerFunc HandlerFunc
}

// RoutesInfo defines a RouteInfo array.
type RoutesInfo []RouteInfo

// Engine is the framework's instance, it contains the muxer, middleware and configuration settings.
// Create an instance of Engine, by using New() or Default()
type Engine struct {
        RouterGroup
        container *framework.HadeContainer

        // Enables automatic redirection if the current route can't be matched but a
        // handler for the path with (without) the trailing slash exists.
        // For example if /foo/ is requested but a route only exists for /foo, the
        // client is redirected to /foo with http status code 301 for GET requests
        // and 307 for all other request methods.
        RedirectTrailingSlash bool

        // If enabled, the router tries to fix the current request path, if no
        // handle is registered for it.
        // First superfluous path elements like ../ or // are removed.
        // Afterwards the router does a case-insensitive lookup of the cleaned path.
        // If a handle can be found for this route, the router makes a redirection
        // to the corrected path with status code 301 for GET requests and 307 for
        // all other request methods.
        // For example /FOO and /..//Foo could be redirected to /foo.
        // RedirectTrailingSlash is independent of this option.
        RedirectFixedPath bool

        // If enabled, the router checks if another method is allowed for the
        // current route, if the current request can not be routed.
        // If this is the case, the request is answered with 'Method Not Allowed'
        // and HTTP status code 405.
        // If no other Method is allowed, the request is delegated to the NotFound
        // handler.
        HandleMethodNotAllowed bool
        ForwardedByClientIP    bool

        // #726 #755 If enabled, it will thrust some headers starting with
        // 'X-AppEngine...' for better integration with that PaaS.
        AppEngine bool

        // If enabled, the url.RawPath will be used to find parameters.
        UseRawPath bool

        // If true, the path value will be unescaped.
        // If UseRawPath is false (by default), the UnescapePathValues effectively is true,
        // as url.Path gonna be used, which is already unescaped.
        UnescapePathValues bool

        // Value of 'maxMemory' param that is given to http.Request's ParseMultipartForm
        // method call.
        MaxMultipartMemory int64

        delims           render.Delims
        secureJsonPrefix string
        HTMLRender       render.HTMLRender
        FuncMap          template.FuncMap
        allNoRoute       HandlersChain
        allNoMethod      HandlersChain
        noRoute          HandlersChain
        noMethod         HandlersChain
        pool             sync.Pool
        trees            methodTrees
}

var _ IRouter = &amp;Engine{}

// New returns a new blank Engine instance without any middleware attached.
// By default the configuration is:
// - RedirectTrailingSlash:  true
// - RedirectFixedPath:      false
// - HandleMethodNotAllowed: false
// - ForwardedByClientIP:    true
// - UseRawPath:             false
// - UnescapePathValues:     true
func New() *Engine <span class="cov8" title="1">{
        debugPrintWARNINGNew()
        engine := &amp;Engine{
                RouterGroup: RouterGroup{
                        Handlers: nil,
                        basePath: "/",
                        root:     true,
                },
                FuncMap:                template.FuncMap{},
                RedirectTrailingSlash:  true,
                RedirectFixedPath:      false,
                HandleMethodNotAllowed: false,
                ForwardedByClientIP:    true,
                AppEngine:              defaultAppEngine,
                UseRawPath:             false,
                UnescapePathValues:     true,
                MaxMultipartMemory:     defaultMultipartMemory,
                trees:                  make(methodTrees, 0, 9),
                delims:                 render.Delims{Left: "{{", Right: "}}"},
                secureJsonPrefix:       "while(1);",
        }
        engine.RouterGroup.engine = engine
        engine.pool.New = func() interface{} </span><span class="cov8" title="1">{
                return engine.allocateContext()
        }</span>
        <span class="cov8" title="1">engine.container = framework.NewHadeContainer()
        return engine</span>
}

// Default returns an Engine instance with the Logger and Recovery middleware already attached.
func Default() *Engine <span class="cov8" title="1">{
        debugPrintWARNINGDefault()
        engine := New()
        engine.Use(Logger(), Recovery())
        return engine
}</span>

func (engine *Engine) allocateContext() *Context <span class="cov8" title="1">{
        return &amp;Context{engine: engine}
}</span>

// Delims sets template left and right delims and returns a Engine instance.
func (engine *Engine) Delims(left, right string) *Engine <span class="cov8" title="1">{
        engine.delims = render.Delims{Left: left, Right: right}
        return engine
}</span>

// SecureJsonPrefix sets the secureJsonPrefix used in Context.SecureJSON.
func (engine *Engine) SecureJsonPrefix(prefix string) *Engine <span class="cov8" title="1">{
        engine.secureJsonPrefix = prefix
        return engine
}</span>

// LoadHTMLGlob loads HTML files identified by glob pattern
// and associates the result with HTML renderer.
func (engine *Engine) LoadHTMLGlob(pattern string) <span class="cov8" title="1">{
        left := engine.delims.Left
        right := engine.delims.Right
        templ := template.Must(template.New("").Delims(left, right).Funcs(engine.FuncMap).ParseGlob(pattern))

        if IsDebugging() </span><span class="cov8" title="1">{
                debugPrintLoadTemplate(templ)
                engine.HTMLRender = render.HTMLDebug{Glob: pattern, FuncMap: engine.FuncMap, Delims: engine.delims}
                return
        }</span>

        <span class="cov8" title="1">engine.SetHTMLTemplate(templ)</span>
}

// LoadHTMLFiles loads a slice of HTML files
// and associates the result with HTML renderer.
func (engine *Engine) LoadHTMLFiles(files ...string) <span class="cov8" title="1">{
        if IsDebugging() </span><span class="cov8" title="1">{
                engine.HTMLRender = render.HTMLDebug{Files: files, FuncMap: engine.FuncMap, Delims: engine.delims}
                return
        }</span>

        <span class="cov8" title="1">templ := template.Must(template.New("").Delims(engine.delims.Left, engine.delims.Right).Funcs(engine.FuncMap).ParseFiles(files...))
        engine.SetHTMLTemplate(templ)</span>
}

// SetHTMLTemplate associate a template with HTML renderer.
func (engine *Engine) SetHTMLTemplate(templ *template.Template) <span class="cov8" title="1">{
        if len(engine.trees) &gt; 0 </span><span class="cov8" title="1">{
                debugPrintWARNINGSetHTMLTemplate()
        }</span>

        <span class="cov8" title="1">engine.HTMLRender = render.HTMLProduction{Template: templ.Funcs(engine.FuncMap)}</span>
}

// SetFuncMap sets the FuncMap used for template.FuncMap.
func (engine *Engine) SetFuncMap(funcMap template.FuncMap) <span class="cov8" title="1">{
        engine.FuncMap = funcMap
}</span>

// NoRoute adds handlers for NoRoute. It return a 404 code by default.
func (engine *Engine) NoRoute(handlers ...HandlerFunc) <span class="cov8" title="1">{
        engine.noRoute = handlers
        engine.rebuild404Handlers()
}</span>

// NoMethod sets the handlers called when... TODO.
func (engine *Engine) NoMethod(handlers ...HandlerFunc) <span class="cov8" title="1">{
        engine.noMethod = handlers
        engine.rebuild405Handlers()
}</span>

// Use attaches a global middleware to the router. ie. the middleware attached though Use() will be
// included in the handlers chain for every single request. Even 404, 405, static files...
// For example, this is the right place for a logger or error management middleware.
func (engine *Engine) Use(middleware ...HandlerFunc) IRoutes <span class="cov8" title="1">{
        engine.RouterGroup.Use(middleware...)
        engine.rebuild404Handlers()
        engine.rebuild405Handlers()
        return engine
}</span>

func (engine *Engine) rebuild404Handlers() <span class="cov8" title="1">{
        engine.allNoRoute = engine.combineHandlers(engine.noRoute)
}</span>

func (engine *Engine) rebuild405Handlers() <span class="cov8" title="1">{
        engine.allNoMethod = engine.combineHandlers(engine.noMethod)
}</span>

func (engine *Engine) addRoute(method, path string, handlers HandlersChain) <span class="cov8" title="1">{
        assert1(path[0] == '/', "path must begin with '/'")
        assert1(method != "", "HTTP method can not be empty")
        assert1(len(handlers) &gt; 0, "there must be at least one handler")

        debugPrintRoute(method, path, handlers)
        root := engine.trees.get(method)
        if root == nil </span><span class="cov8" title="1">{
                root = new(node)
                engine.trees = append(engine.trees, methodTree{method: method, root: root})
        }</span>
        <span class="cov8" title="1">root.addRoute(path, handlers)</span>
}

// Routes returns a slice of registered routes, including some useful information, such as:
// the http method, path and the handler name.
func (engine *Engine) Routes() (routes RoutesInfo) <span class="cov8" title="1">{
        for _, tree := range engine.trees </span><span class="cov8" title="1">{
                routes = iterate("", tree.method, routes, tree.root)
        }</span>
        <span class="cov8" title="1">return routes</span>
}

func iterate(path, method string, routes RoutesInfo, root *node) RoutesInfo <span class="cov8" title="1">{
        path += root.path
        if len(root.handlers) &gt; 0 </span><span class="cov8" title="1">{
                handlerFunc := root.handlers.Last()
                routes = append(routes, RouteInfo{
                        Method:      method,
                        Path:        path,
                        Handler:     nameOfFunction(handlerFunc),
                        HandlerFunc: handlerFunc,
                })
        }</span>
        <span class="cov8" title="1">for _, child := range root.children </span><span class="cov8" title="1">{
                routes = iterate(path, method, routes, child)
        }</span>
        <span class="cov8" title="1">return routes</span>
}

// Run attaches the router to a http.Server and starts listening and serving HTTP requests.
// It is a shortcut for http.ListenAndServe(addr, router)
// Note: this method will block the calling goroutine indefinitely unless an error happens.
func (engine *Engine) Run(addr ...string) (err error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{ debugPrintError(err) }</span>()

        <span class="cov8" title="1">address := resolveAddress(addr)
        debugPrint("Listening and serving HTTP on %s\n", address)
        err = http.ListenAndServe(address, engine)
        return</span>
}

// RunTLS attaches the router to a http.Server and starts listening and serving HTTPS (secure) requests.
// It is a shortcut for http.ListenAndServeTLS(addr, certFile, keyFile, router)
// Note: this method will block the calling goroutine indefinitely unless an error happens.
func (engine *Engine) RunTLS(addr, certFile, keyFile string) (err error) <span class="cov8" title="1">{
        debugPrint("Listening and serving HTTPS on %s\n", addr)
        defer func() </span><span class="cov8" title="1">{ debugPrintError(err) }</span>()

        <span class="cov8" title="1">err = http.ListenAndServeTLS(addr, certFile, keyFile, engine)
        return</span>
}

// RunUnix attaches the router to a http.Server and starts listening and serving HTTP requests
// through the specified unix socket (ie. a file).
// Note: this method will block the calling goroutine indefinitely unless an error happens.
func (engine *Engine) RunUnix(file string) (err error) <span class="cov8" title="1">{
        debugPrint("Listening and serving HTTP on unix:/%s", file)
        defer func() </span><span class="cov8" title="1">{ debugPrintError(err) }</span>()

        <span class="cov8" title="1">os.Remove(file)
        listener, err := net.Listen("unix", file)
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">defer listener.Close()
        os.Chmod(file, 0777)
        err = http.Serve(listener, engine)
        return</span>
}

// RunFd attaches the router to a http.Server and starts listening and serving HTTP requests
// through the specified file descriptor.
// Note: this method will block the calling goroutine indefinitely unless an error happens.
func (engine *Engine) RunFd(fd int) (err error) <span class="cov8" title="1">{
        debugPrint("Listening and serving HTTP on fd@%d", fd)
        defer func() </span><span class="cov8" title="1">{ debugPrintError(err) }</span>()

        <span class="cov8" title="1">f := os.NewFile(uintptr(fd), fmt.Sprintf("fd@%d", fd))
        listener, err := net.FileListener(f)
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">defer listener.Close()
        err = http.Serve(listener, engine)
        return</span>
}

// ServeHTTP conforms to the http.Handler interface.
func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        c := engine.pool.Get().(*Context)
        c.HadeContainer = engine.container
        c.writermem.reset(w)
        c.Request = req
        c.reset()

        engine.handleHTTPRequest(c)

        engine.pool.Put(c)
}</span>

// HandleContext re-enter a context that has been rewritten.
// This can be done by setting c.Request.URL.Path to your new target.
// Disclaimer: You can loop yourself to death with this, use wisely.
func (engine *Engine) HandleContext(c *Context) <span class="cov8" title="1">{
        oldIndexValue := c.index
        c.reset()
        engine.handleHTTPRequest(c)

        c.index = oldIndexValue
}</span>

func (engine *Engine) handleHTTPRequest(c *Context) <span class="cov8" title="1">{
        httpMethod := c.Request.Method
        rPath := c.Request.URL.Path
        unescape := false
        if engine.UseRawPath &amp;&amp; len(c.Request.URL.RawPath) &gt; 0 </span><span class="cov8" title="1">{
                rPath = c.Request.URL.RawPath
                unescape = engine.UnescapePathValues
        }</span>
        <span class="cov8" title="1">rPath = cleanPath(rPath)

        // Find root of the tree for the given HTTP method
        t := engine.trees
        for i, tl := 0, len(t); i &lt; tl; i++ </span><span class="cov8" title="1">{
                if t[i].method != httpMethod </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">root := t[i].root
                // Find route in tree
                handlers, params, tsr := root.getValue(rPath, c.Params, unescape)
                if handlers != nil </span><span class="cov8" title="1">{
                        c.handlers = handlers
                        c.Params = params
                        c.Next()
                        c.writermem.WriteHeaderNow()
                        return
                }</span>
                <span class="cov8" title="1">if httpMethod != "CONNECT" &amp;&amp; rPath != "/" </span><span class="cov8" title="1">{
                        if tsr &amp;&amp; engine.RedirectTrailingSlash </span><span class="cov8" title="1">{
                                redirectTrailingSlash(c)
                                return
                        }</span>
                        <span class="cov8" title="1">if engine.RedirectFixedPath &amp;&amp; redirectFixedPath(c, root, engine.RedirectFixedPath) </span><span class="cov8" title="1">{
                                return
                        }</span>
                }
                <span class="cov8" title="1">break</span>
        }

        <span class="cov8" title="1">if engine.HandleMethodNotAllowed </span><span class="cov8" title="1">{
                for _, tree := range engine.trees </span><span class="cov8" title="1">{
                        if tree.method == httpMethod </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if handlers, _, _ := tree.root.getValue(rPath, nil, unescape); handlers != nil </span><span class="cov8" title="1">{
                                c.handlers = engine.allNoMethod
                                serveError(c, http.StatusMethodNotAllowed, default405Body)
                                return
                        }</span>
                }
        }
        <span class="cov8" title="1">c.handlers = engine.allNoRoute
        serveError(c, http.StatusNotFound, default404Body)</span>
}

var mimePlain = []string{MIMEPlain}

func serveError(c *Context, code int, defaultMessage []byte) <span class="cov8" title="1">{
        c.writermem.status = code
        c.Next()
        if c.writermem.Written() </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if c.writermem.Status() == code </span><span class="cov8" title="1">{
                c.writermem.Header()["Content-Type"] = mimePlain
                _, err := c.Writer.Write(defaultMessage)
                if err != nil </span><span class="cov0" title="0">{
                        debugPrint("cannot write message to writer during serve error: %v", err)
                }</span>
                <span class="cov8" title="1">return</span>
        }
        <span class="cov8" title="1">c.writermem.WriteHeaderNow()
        return</span>
}

func redirectTrailingSlash(c *Context) <span class="cov8" title="1">{
        req := c.Request
        p := req.URL.Path
        if prefix := path.Clean(c.Request.Header.Get("X-Forwarded-Prefix")); prefix != "." </span><span class="cov8" title="1">{
                p = prefix + "/" + req.URL.Path
        }</span>
        <span class="cov8" title="1">code := http.StatusMovedPermanently // Permanent redirect, request with GET method
        if req.Method != "GET" </span><span class="cov8" title="1">{
                code = http.StatusTemporaryRedirect
        }</span>

        <span class="cov8" title="1">req.URL.Path = p + "/"
        if length := len(p); length &gt; 1 &amp;&amp; p[length-1] == '/' </span><span class="cov8" title="1">{
                req.URL.Path = p[:length-1]
        }</span>
        <span class="cov8" title="1">debugPrint("redirecting request %d: %s --&gt; %s", code, p, req.URL.String())
        http.Redirect(c.Writer, req, req.URL.String(), code)
        c.writermem.WriteHeaderNow()</span>
}

func redirectFixedPath(c *Context, root *node, trailingSlash bool) bool <span class="cov8" title="1">{
        req := c.Request
        rPath := req.URL.Path

        if fixedPath, ok := root.findCaseInsensitivePath(cleanPath(rPath), trailingSlash); ok </span><span class="cov8" title="1">{
                code := http.StatusMovedPermanently // Permanent redirect, request with GET method
                if req.Method != "GET" </span><span class="cov8" title="1">{
                        code = http.StatusTemporaryRedirect
                }</span>
                <span class="cov8" title="1">req.URL.Path = string(fixedPath)
                debugPrint("redirecting request %d: %s --&gt; %s", code, rPath, req.URL.String())
                http.Redirect(c.Writer, req, req.URL.String(), code)
                c.writermem.WriteHeaderNow()
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package gin

import "github.com/jianfengye/hade/framework"

// Hade framework add functions

// Register register a service provider for hade framework
func Register(engine *Engine, provider framework.ServiceProvider, isSingleton bool) error <span class="cov0" title="0">{
        return engine.container.Bind(provider, isSingleton)
}</span>

// Register register a singleton serviceProvider
func RegisterSingleton(engine *Engine, provider framework.ServiceProvider) error <span class="cov0" title="0">{
        return engine.container.Bind(provider, true)
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">// Copyright 2014 Manu Martinez-Almeida.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package gin

import (
        "fmt"
        "io"
        "net/http"
        "os"
        "time"

        "github.com/mattn/go-isatty"
)

type consoleColorModeValue int

const (
        autoColor consoleColorModeValue = iota
        disableColor
        forceColor
)

var (
        green            = string([]byte{27, 91, 57, 55, 59, 52, 50, 109})
        white            = string([]byte{27, 91, 57, 48, 59, 52, 55, 109})
        yellow           = string([]byte{27, 91, 57, 48, 59, 52, 51, 109})
        red              = string([]byte{27, 91, 57, 55, 59, 52, 49, 109})
        blue             = string([]byte{27, 91, 57, 55, 59, 52, 52, 109})
        magenta          = string([]byte{27, 91, 57, 55, 59, 52, 53, 109})
        cyan             = string([]byte{27, 91, 57, 55, 59, 52, 54, 109})
        reset            = string([]byte{27, 91, 48, 109})
        consoleColorMode = autoColor
)

// LoggerConfig defines the config for Logger middleware.
type LoggerConfig struct {
        // Optional. Default value is gin.defaultLogFormatter
        Formatter LogFormatter

        // Output is a writer where logs are written.
        // Optional. Default value is gin.DefaultWriter.
        Output io.Writer

        // SkipPaths is a url path array which logs are not written.
        // Optional.
        SkipPaths []string
}

// LogFormatter gives the signature of the formatter function passed to LoggerWithFormatter
type LogFormatter func(params LogFormatterParams) string

// LogFormatterParams is the structure any formatter will be handed when time to log comes
type LogFormatterParams struct {
        Request *http.Request

        // TimeStamp shows the time after the server returns a response.
        TimeStamp time.Time
        // StatusCode is HTTP response code.
        StatusCode int
        // Latency is how much time the server cost to process a certain request.
        Latency time.Duration
        // ClientIP equals Context's ClientIP method.
        ClientIP string
        // Method is the HTTP method given to the request.
        Method string
        // Path is a path the client requests.
        Path string
        // ErrorMessage is set if error has occurred in processing the request.
        ErrorMessage string
        // isTerm shows whether does gin's output descriptor refers to a terminal.
        isTerm bool
        // BodySize is the size of the Response Body
        BodySize int
        // Keys are the keys set on the request's context.
        Keys map[string]interface{}
}

// StatusCodeColor is the ANSI color for appropriately logging http status code to a terminal.
func (p *LogFormatterParams) StatusCodeColor() string <span class="cov8" title="1">{
        code := p.StatusCode

        switch </span>{
        case code &gt;= http.StatusOK &amp;&amp; code &lt; http.StatusMultipleChoices:<span class="cov8" title="1">
                return green</span>
        case code &gt;= http.StatusMultipleChoices &amp;&amp; code &lt; http.StatusBadRequest:<span class="cov8" title="1">
                return white</span>
        case code &gt;= http.StatusBadRequest &amp;&amp; code &lt; http.StatusInternalServerError:<span class="cov8" title="1">
                return yellow</span>
        default:<span class="cov8" title="1">
                return red</span>
        }
}

// MethodColor is the ANSI color for appropriately logging http method to a terminal.
func (p *LogFormatterParams) MethodColor() string <span class="cov8" title="1">{
        method := p.Method

        switch method </span>{
        case "GET":<span class="cov8" title="1">
                return blue</span>
        case "POST":<span class="cov8" title="1">
                return cyan</span>
        case "PUT":<span class="cov8" title="1">
                return yellow</span>
        case "DELETE":<span class="cov8" title="1">
                return red</span>
        case "PATCH":<span class="cov8" title="1">
                return green</span>
        case "HEAD":<span class="cov8" title="1">
                return magenta</span>
        case "OPTIONS":<span class="cov8" title="1">
                return white</span>
        default:<span class="cov8" title="1">
                return reset</span>
        }
}

// ResetColor resets all escape attributes.
func (p *LogFormatterParams) ResetColor() string <span class="cov8" title="1">{
        return reset
}</span>

// IsOutputColor indicates whether can colors be outputted to the log.
func (p *LogFormatterParams) IsOutputColor() bool <span class="cov8" title="1">{
        return consoleColorMode == forceColor || (consoleColorMode == autoColor &amp;&amp; p.isTerm)
}</span>

// defaultLogFormatter is the default log format function Logger middleware uses.
var defaultLogFormatter = func(param LogFormatterParams) string <span class="cov8" title="1">{
        var statusColor, methodColor, resetColor string
        if param.IsOutputColor() </span><span class="cov8" title="1">{
                statusColor = param.StatusCodeColor()
                methodColor = param.MethodColor()
                resetColor = param.ResetColor()
        }</span>

        <span class="cov8" title="1">if param.Latency &gt; time.Minute </span><span class="cov8" title="1">{
                // Truncate in a golang &lt; 1.8 safe way
                param.Latency = param.Latency - param.Latency%time.Second
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("[GIN] %v |%s %3d %s| %13v | %15s |%s %-7s %s %s\n%s",
                param.TimeStamp.Format("2006/01/02 - 15:04:05"),
                statusColor, param.StatusCode, resetColor,
                param.Latency,
                param.ClientIP,
                methodColor, param.Method, resetColor,
                param.Path,
                param.ErrorMessage,
        )</span>
}

// DisableConsoleColor disables color output in the console.
func DisableConsoleColor() <span class="cov8" title="1">{
        consoleColorMode = disableColor
}</span>

// ForceConsoleColor force color output in the console.
func ForceConsoleColor() <span class="cov8" title="1">{
        consoleColorMode = forceColor
}</span>

// ErrorLogger returns a handlerfunc for any error type.
func ErrorLogger() HandlerFunc <span class="cov8" title="1">{
        return ErrorLoggerT(ErrorTypeAny)
}</span>

// ErrorLoggerT returns a handlerfunc for a given error type.
func ErrorLoggerT(typ ErrorType) HandlerFunc <span class="cov8" title="1">{
        return func(c *Context) </span><span class="cov8" title="1">{
                c.Next()
                errors := c.Errors.ByType(typ)
                if len(errors) &gt; 0 </span><span class="cov8" title="1">{
                        c.JSON(-1, errors)
                }</span>
        }
}

// Logger instances a Logger middleware that will write the logs to gin.DefaultWriter.
// By default gin.DefaultWriter = os.Stdout.
func Logger() HandlerFunc <span class="cov8" title="1">{
        return LoggerWithConfig(LoggerConfig{})
}</span>

// LoggerWithFormatter instance a Logger middleware with the specified log format function.
func LoggerWithFormatter(f LogFormatter) HandlerFunc <span class="cov8" title="1">{
        return LoggerWithConfig(LoggerConfig{
                Formatter: f,
        })
}</span>

// LoggerWithWriter instance a Logger middleware with the specified writer buffer.
// Example: os.Stdout, a file opened in write mode, a socket...
func LoggerWithWriter(out io.Writer, notlogged ...string) HandlerFunc <span class="cov8" title="1">{
        return LoggerWithConfig(LoggerConfig{
                Output:    out,
                SkipPaths: notlogged,
        })
}</span>

// LoggerWithConfig instance a Logger middleware with config.
func LoggerWithConfig(conf LoggerConfig) HandlerFunc <span class="cov8" title="1">{
        formatter := conf.Formatter
        if formatter == nil </span><span class="cov8" title="1">{
                formatter = defaultLogFormatter
        }</span>

        <span class="cov8" title="1">out := conf.Output
        if out == nil </span><span class="cov8" title="1">{
                out = DefaultWriter
        }</span>

        <span class="cov8" title="1">notlogged := conf.SkipPaths

        isTerm := true

        if w, ok := out.(*os.File); !ok || os.Getenv("TERM") == "dumb" ||
                (!isatty.IsTerminal(w.Fd()) &amp;&amp; !isatty.IsCygwinTerminal(w.Fd())) </span><span class="cov8" title="1">{
                isTerm = false
        }</span>

        <span class="cov8" title="1">var skip map[string]struct{}

        if length := len(notlogged); length &gt; 0 </span><span class="cov8" title="1">{
                skip = make(map[string]struct{}, length)

                for _, path := range notlogged </span><span class="cov8" title="1">{
                        skip[path] = struct{}{}
                }</span>
        }

        <span class="cov8" title="1">return func(c *Context) </span><span class="cov8" title="1">{
                // Start timer
                start := time.Now()
                path := c.Request.URL.Path
                raw := c.Request.URL.RawQuery

                // Process request
                c.Next()

                // Log only when path is not being skipped
                if _, ok := skip[path]; !ok </span><span class="cov8" title="1">{
                        param := LogFormatterParams{
                                Request: c.Request,
                                isTerm:  isTerm,
                                Keys:    c.Keys,
                        }

                        // Stop timer
                        param.TimeStamp = time.Now()
                        param.Latency = param.TimeStamp.Sub(start)

                        param.ClientIP = c.ClientIP()
                        param.Method = c.Request.Method
                        param.StatusCode = c.Writer.Status()
                        param.ErrorMessage = c.Errors.ByType(ErrorTypePrivate).String()

                        param.BodySize = c.Writer.Size()

                        if raw != "" </span><span class="cov8" title="1">{
                                path = path + "?" + raw
                        }</span>

                        <span class="cov8" title="1">param.Path = path

                        fmt.Fprint(out, formatter(param))</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file33" style="display: none">// Copyright 2014 Manu Martinez-Almeida.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package gin

import (
        "io"
        "os"

        "github.com/jianfengye/hade/gin/binding"
)

// EnvGinMode indicates environment name for gin mode.
const EnvGinMode = "GIN_MODE"

const (
        // DebugMode indicates gin mode is debug.
        DebugMode = "debug"
        // ReleaseMode indicates gin mode is release.
        ReleaseMode = "release"
        // TestMode indicates gin mode is test.
        TestMode = "test"
)
const (
        debugCode = iota
        releaseCode
        testCode
)

// DefaultWriter is the default io.Writer used by Gin for debug output and
// middleware output like Logger() or Recovery().
// Note that both Logger and Recovery provides custom ways to configure their
// output io.Writer.
// To support coloring in Windows use:
//                 import "github.com/mattn/go-colorable"
//                 gin.DefaultWriter = colorable.NewColorableStdout()
var DefaultWriter io.Writer = os.Stdout

// DefaultErrorWriter is the default io.Writer used by Gin to debug errors
var DefaultErrorWriter io.Writer = os.Stderr

var ginMode = debugCode
var modeName = DebugMode

func init() <span class="cov8" title="1">{
        mode := os.Getenv(EnvGinMode)
        SetMode(mode)
}</span>

// SetMode sets gin mode according to input string.
func SetMode(value string) <span class="cov8" title="1">{
        switch value </span>{
        case DebugMode, "":<span class="cov8" title="1">
                ginMode = debugCode</span>
        case ReleaseMode:<span class="cov8" title="1">
                ginMode = releaseCode</span>
        case TestMode:<span class="cov8" title="1">
                ginMode = testCode</span>
        default:<span class="cov8" title="1">
                panic("gin mode unknown: " + value)</span>
        }
        <span class="cov8" title="1">if value == "" </span><span class="cov8" title="1">{
                value = DebugMode
        }</span>
        <span class="cov8" title="1">modeName = value</span>
}

// DisableBindValidation closes the default validator.
func DisableBindValidation() <span class="cov0" title="0">{
        binding.Validator = nil
}</span>

// EnableJsonDecoderUseNumber sets true for binding.EnableDecoderUseNumberto to
// call the UseNumber method on the JSON Decoder instance.
func EnableJsonDecoderUseNumber() <span class="cov8" title="1">{
        binding.EnableDecoderUseNumber = true
}</span>

// Mode returns currently gin mode.
func Mode() string <span class="cov8" title="1">{
        return modeName
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">// Copyright 2013 Julien Schmidt. All rights reserved.
// Based on the path package, Copyright 2009 The Go Authors.
// Use of this source code is governed by a BSD-style license that can be found
// at https://github.com/julienschmidt/httprouter/blob/master/LICENSE.

package gin

// cleanPath is the URL version of path.Clean, it returns a canonical URL path
// for p, eliminating . and .. elements.
//
// The following rules are applied iteratively until no further processing can
// be done:
//        1. Replace multiple slashes with a single slash.
//        2. Eliminate each . path name element (the current directory).
//        3. Eliminate each inner .. path name element (the parent directory)
//           along with the non-.. element that precedes it.
//        4. Eliminate .. elements that begin a rooted path:
//           that is, replace "/.." by "/" at the beginning of a path.
//
// If the result of this process is an empty string, "/" is returned.
func cleanPath(p string) string <span class="cov8" title="1">{
        // Turn empty string into "/"
        if p == "" </span><span class="cov8" title="1">{
                return "/"
        }</span>

        <span class="cov8" title="1">n := len(p)
        var buf []byte

        // Invariants:
        //      reading from path; r is index of next byte to process.
        //      writing to buf; w is index of next byte to write.

        // path must start with '/'
        r := 1
        w := 1

        if p[0] != '/' </span><span class="cov8" title="1">{
                r = 0
                buf = make([]byte, n+1)
                buf[0] = '/'
        }</span>

        <span class="cov8" title="1">trailing := n &gt; 1 &amp;&amp; p[n-1] == '/'

        // A bit more clunky without a 'lazybuf' like the path package, but the loop
        // gets completely inlined (bufApp). So in contrast to the path package this
        // loop has no expensive function calls (except 1x make)

        for r &lt; n </span><span class="cov8" title="1">{
                switch </span>{
                case p[r] == '/':<span class="cov8" title="1">
                        // empty path element, trailing slash is added after the end
                        r++</span>

                case p[r] == '.' &amp;&amp; r+1 == n:<span class="cov8" title="1">
                        trailing = true
                        r++</span>

                case p[r] == '.' &amp;&amp; p[r+1] == '/':<span class="cov8" title="1">
                        // . element
                        r += 2</span>

                case p[r] == '.' &amp;&amp; p[r+1] == '.' &amp;&amp; (r+2 == n || p[r+2] == '/'):<span class="cov8" title="1">
                        // .. element: remove to last /
                        r += 3

                        if w &gt; 1 </span><span class="cov8" title="1">{
                                // can backtrack
                                w--

                                if buf == nil </span><span class="cov8" title="1">{
                                        for w &gt; 1 &amp;&amp; p[w] != '/' </span><span class="cov8" title="1">{
                                                w--
                                        }</span>
                                } else<span class="cov8" title="1"> {
                                        for w &gt; 1 &amp;&amp; buf[w] != '/' </span><span class="cov8" title="1">{
                                                w--
                                        }</span>
                                }
                        }

                default:<span class="cov8" title="1">
                        // real path element.
                        // add slash if needed
                        if w &gt; 1 </span><span class="cov8" title="1">{
                                bufApp(&amp;buf, p, w, '/')
                                w++
                        }</span>

                        // copy element
                        <span class="cov8" title="1">for r &lt; n &amp;&amp; p[r] != '/' </span><span class="cov8" title="1">{
                                bufApp(&amp;buf, p, w, p[r])
                                w++
                                r++
                        }</span>
                }
        }

        // re-append trailing slash
        <span class="cov8" title="1">if trailing &amp;&amp; w &gt; 1 </span><span class="cov8" title="1">{
                bufApp(&amp;buf, p, w, '/')
                w++
        }</span>

        <span class="cov8" title="1">if buf == nil </span><span class="cov8" title="1">{
                return p[:w]
        }</span>
        <span class="cov8" title="1">return string(buf[:w])</span>
}

// internal helper to lazily create a buffer if necessary.
func bufApp(buf *[]byte, s string, w int, c byte) <span class="cov8" title="1">{
        if *buf == nil </span><span class="cov8" title="1">{
                if s[w] == c </span><span class="cov8" title="1">{
                        return
                }</span>

                <span class="cov8" title="1">*buf = make([]byte, len(s))
                copy(*buf, s[:w])</span>
        }
        <span class="cov8" title="1">(*buf)[w] = c</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">// Copyright 2014 Manu Martinez-Almeida.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package gin

import (
        "bytes"
        "fmt"
        "io"
        "io/ioutil"
        "log"
        "net"
        "net/http"
        "net/http/httputil"
        "os"
        "runtime"
        "strings"
        "time"
)

var (
        dunno     = []byte("???")
        centerDot = []byte("Â·")
        dot       = []byte(".")
        slash     = []byte("/")
)

// Recovery returns a middleware that recovers from any panics and writes a 500 if there was one.
func Recovery() HandlerFunc <span class="cov8" title="1">{
        return RecoveryWithWriter(DefaultErrorWriter)
}</span>

// RecoveryWithWriter returns a middleware for a given writer that recovers from any panics and writes a 500 if there was one.
func RecoveryWithWriter(out io.Writer) HandlerFunc <span class="cov8" title="1">{
        var logger *log.Logger
        if out != nil </span><span class="cov8" title="1">{
                logger = log.New(out, "\n\n\x1b[31m", log.LstdFlags)
        }</span>
        <span class="cov8" title="1">return func(c *Context) </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        if err := recover(); err != nil </span><span class="cov8" title="1">{
                                // Check for a broken connection, as it is not really a
                                // condition that warrants a panic stack trace.
                                var brokenPipe bool
                                if ne, ok := err.(*net.OpError); ok </span><span class="cov8" title="1">{
                                        if se, ok := ne.Err.(*os.SyscallError); ok </span><span class="cov8" title="1">{
                                                if strings.Contains(strings.ToLower(se.Error()), "broken pipe") || strings.Contains(strings.ToLower(se.Error()), "connection reset by peer") </span><span class="cov8" title="1">{
                                                        brokenPipe = true
                                                }</span>
                                        }
                                }
                                <span class="cov8" title="1">if logger != nil </span><span class="cov8" title="1">{
                                        stack := stack(3)
                                        httpRequest, _ := httputil.DumpRequest(c.Request, false)
                                        headers := strings.Split(string(httpRequest), "\r\n")
                                        for idx, header := range headers </span><span class="cov8" title="1">{
                                                current := strings.Split(header, ":")
                                                if current[0] == "Authorization" </span><span class="cov8" title="1">{
                                                        headers[idx] = current[0] + ": *"
                                                }</span>
                                        }
                                        <span class="cov8" title="1">if brokenPipe </span><span class="cov8" title="1">{
                                                logger.Printf("%s\n%s%s", err, string(httpRequest), reset)
                                        }</span> else<span class="cov8" title="1"> if IsDebugging() </span><span class="cov8" title="1">{
                                                logger.Printf("[Recovery] %s panic recovered:\n%s\n%s\n%s%s",
                                                        timeFormat(time.Now()), strings.Join(headers, "\r\n"), err, stack, reset)
                                        }</span> else<span class="cov8" title="1"> {
                                                logger.Printf("[Recovery] %s panic recovered:\n%s\n%s%s",
                                                        timeFormat(time.Now()), err, stack, reset)
                                        }</span>
                                }

                                // If the connection is dead, we can't write a status to it.
                                <span class="cov8" title="1">if brokenPipe </span><span class="cov8" title="1">{
                                        c.Error(err.(error)) // nolint: errcheck
                                        c.Abort()
                                }</span> else<span class="cov8" title="1"> {
                                        c.AbortWithStatus(http.StatusInternalServerError)
                                }</span>
                        }
                }()
                <span class="cov8" title="1">c.Next()</span>
        }
}

// stack returns a nicely formatted stack frame, skipping skip frames.
func stack(skip int) []byte <span class="cov8" title="1">{
        buf := new(bytes.Buffer) // the returned data
        // As we loop, we open files and read them. These variables record the currently
        // loaded file.
        var lines [][]byte
        var lastFile string
        for i := skip; ; i++ </span><span class="cov8" title="1">{ // Skip the expected number of frames
                pc, file, line, ok := runtime.Caller(i)
                if !ok </span><span class="cov8" title="1">{
                        break</span>
                }
                // Print this much at least.  If we can't find the source, it won't show.
                <span class="cov8" title="1">fmt.Fprintf(buf, "%s:%d (0x%x)\n", file, line, pc)
                if file != lastFile </span><span class="cov8" title="1">{
                        data, err := ioutil.ReadFile(file)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">lines = bytes.Split(data, []byte{'\n'})
                        lastFile = file</span>
                }
                <span class="cov8" title="1">fmt.Fprintf(buf, "\t%s: %s\n", function(pc), source(lines, line))</span>
        }
        <span class="cov8" title="1">return buf.Bytes()</span>
}

// source returns a space-trimmed slice of the n'th line.
func source(lines [][]byte, n int) []byte <span class="cov8" title="1">{
        n-- // in stack trace, lines are 1-indexed but our array is 0-indexed
        if n &lt; 0 || n &gt;= len(lines) </span><span class="cov8" title="1">{
                return dunno
        }</span>
        <span class="cov8" title="1">return bytes.TrimSpace(lines[n])</span>
}

// function returns, if possible, the name of the function containing the PC.
func function(pc uintptr) []byte <span class="cov8" title="1">{
        fn := runtime.FuncForPC(pc)
        if fn == nil </span><span class="cov8" title="1">{
                return dunno
        }</span>
        <span class="cov8" title="1">name := []byte(fn.Name())
        // The name includes the path name to the package, which is unnecessary
        // since the file name is already included.  Plus, it has center dots.
        // That is, we see
        //        runtime/debug.*TÂ·ptrmethod
        // and want
        //        *T.ptrmethod
        // Also the package path might contains dot (e.g. code.google.com/...),
        // so first eliminate the path prefix
        if lastSlash := bytes.LastIndex(name, slash); lastSlash &gt;= 0 </span><span class="cov8" title="1">{
                name = name[lastSlash+1:]
        }</span>
        <span class="cov8" title="1">if period := bytes.Index(name, dot); period &gt;= 0 </span><span class="cov8" title="1">{
                name = name[period+1:]
        }</span>
        <span class="cov8" title="1">name = bytes.Replace(name, centerDot, dot, -1)
        return name</span>
}

func timeFormat(t time.Time) string <span class="cov8" title="1">{
        var timeString = t.Format("2006/01/02 - 15:04:05")
        return timeString
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">// Copyright 2014 Manu Martinez-Almeida.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package render

import "net/http"

// Data contains ContentType and bytes data.
type Data struct {
        ContentType string
        Data        []byte
}

// Render (Data) writes data with custom ContentType.
func (r Data) Render(w http.ResponseWriter) (err error) <span class="cov8" title="1">{
        r.WriteContentType(w)
        _, err = w.Write(r.Data)
        return
}</span>

// WriteContentType (Data) writes custom ContentType.
func (r Data) WriteContentType(w http.ResponseWriter) <span class="cov8" title="1">{
        writeContentType(w, []string{r.ContentType})
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">// Copyright 2014 Manu Martinez-Almeida.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package render

import (
        "html/template"
        "net/http"
)

// Delims represents a set of Left and Right delimiters for HTML template rendering.
type Delims struct {
        // Left delimiter, defaults to {{.
        Left string
        // Right delimiter, defaults to }}.
        Right string
}

// HTMLRender interface is to be implemented by HTMLProduction and HTMLDebug.
type HTMLRender interface {
        // Instance returns an HTML instance.
        Instance(string, interface{}) Render
}

// HTMLProduction contains template reference and its delims.
type HTMLProduction struct {
        Template *template.Template
        Delims   Delims
}

// HTMLDebug contains template delims and pattern and function with file list.
type HTMLDebug struct {
        Files   []string
        Glob    string
        Delims  Delims
        FuncMap template.FuncMap
}

// HTML contains template reference and its name with given interface object.
type HTML struct {
        Template *template.Template
        Name     string
        Data     interface{}
}

var htmlContentType = []string{"text/html; charset=utf-8"}

// Instance (HTMLProduction) returns an HTML instance which it realizes Render interface.
func (r HTMLProduction) Instance(name string, data interface{}) Render <span class="cov8" title="1">{
        return HTML{
                Template: r.Template,
                Name:     name,
                Data:     data,
        }
}</span>

// Instance (HTMLDebug) returns an HTML instance which it realizes Render interface.
func (r HTMLDebug) Instance(name string, data interface{}) Render <span class="cov8" title="1">{
        return HTML{
                Template: r.loadTemplate(),
                Name:     name,
                Data:     data,
        }
}</span>
func (r HTMLDebug) loadTemplate() *template.Template <span class="cov8" title="1">{
        if r.FuncMap == nil </span><span class="cov8" title="1">{
                r.FuncMap = template.FuncMap{}
        }</span>
        <span class="cov8" title="1">if len(r.Files) &gt; 0 </span><span class="cov8" title="1">{
                return template.Must(template.New("").Delims(r.Delims.Left, r.Delims.Right).Funcs(r.FuncMap).ParseFiles(r.Files...))
        }</span>
        <span class="cov8" title="1">if r.Glob != "" </span><span class="cov8" title="1">{
                return template.Must(template.New("").Delims(r.Delims.Left, r.Delims.Right).Funcs(r.FuncMap).ParseGlob(r.Glob))
        }</span>
        <span class="cov8" title="1">panic("the HTML debug render was created without files or glob pattern")</span>
}

// Render (HTML) executes template and writes its result with custom ContentType for response.
func (r HTML) Render(w http.ResponseWriter) error <span class="cov8" title="1">{
        r.WriteContentType(w)

        if r.Name == "" </span><span class="cov8" title="1">{
                return r.Template.Execute(w, r.Data)
        }</span>
        <span class="cov8" title="1">return r.Template.ExecuteTemplate(w, r.Name, r.Data)</span>
}

// WriteContentType (HTML) writes HTML ContentType.
func (r HTML) WriteContentType(w http.ResponseWriter) <span class="cov8" title="1">{
        writeContentType(w, htmlContentType)
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">// Copyright 2014 Manu Martinez-Almeida.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package render

import (
        "bytes"
        "fmt"
        "html/template"
        "net/http"

        "github.com/jianfengye/hade/gin/internal/json"
)

// JSON contains the given interface object.
type JSON struct {
        Data interface{}
}

// IndentedJSON contains the given interface object.
type IndentedJSON struct {
        Data interface{}
}

// SecureJSON contains the given interface object and its prefix.
type SecureJSON struct {
        Prefix string
        Data   interface{}
}

// JsonpJSON contains the given interface object its callback.
type JsonpJSON struct {
        Callback string
        Data     interface{}
}

// AsciiJSON contains the given interface object.
type AsciiJSON struct {
        Data interface{}
}

// SecureJSONPrefix is a string which represents SecureJSON prefix.
type SecureJSONPrefix string

// PureJSON contains the given interface object.
type PureJSON struct {
        Data interface{}
}

var jsonContentType = []string{"application/json; charset=utf-8"}
var jsonpContentType = []string{"application/javascript; charset=utf-8"}
var jsonAsciiContentType = []string{"application/json"}

// Render (JSON) writes data with custom ContentType.
func (r JSON) Render(w http.ResponseWriter) (err error) <span class="cov8" title="1">{
        if err = WriteJSON(w, r.Data); err != nil </span><span class="cov8" title="1">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return</span>
}

// WriteContentType (JSON) writes JSON ContentType.
func (r JSON) WriteContentType(w http.ResponseWriter) <span class="cov8" title="1">{
        writeContentType(w, jsonContentType)
}</span>

// WriteJSON marshals the given interface object and writes it with custom ContentType.
func WriteJSON(w http.ResponseWriter, obj interface{}) error <span class="cov8" title="1">{
        writeContentType(w, jsonContentType)
        jsonBytes, err := json.Marshal(obj)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">_, err = w.Write(jsonBytes)
        return err</span>
}

// Render (IndentedJSON) marshals the given interface object and writes it with custom ContentType.
func (r IndentedJSON) Render(w http.ResponseWriter) error <span class="cov8" title="1">{
        r.WriteContentType(w)
        jsonBytes, err := json.MarshalIndent(r.Data, "", "    ")
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">_, err = w.Write(jsonBytes)
        return err</span>
}

// WriteContentType (IndentedJSON) writes JSON ContentType.
func (r IndentedJSON) WriteContentType(w http.ResponseWriter) <span class="cov8" title="1">{
        writeContentType(w, jsonContentType)
}</span>

// Render (SecureJSON) marshals the given interface object and writes it with custom ContentType.
func (r SecureJSON) Render(w http.ResponseWriter) error <span class="cov8" title="1">{
        r.WriteContentType(w)
        jsonBytes, err := json.Marshal(r.Data)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        // if the jsonBytes is array values
        <span class="cov8" title="1">if bytes.HasPrefix(jsonBytes, []byte("[")) &amp;&amp; bytes.HasSuffix(jsonBytes, []byte("]")) </span><span class="cov8" title="1">{
                _, err = w.Write([]byte(r.Prefix))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">_, err = w.Write(jsonBytes)
        return err</span>
}

// WriteContentType (SecureJSON) writes JSON ContentType.
func (r SecureJSON) WriteContentType(w http.ResponseWriter) <span class="cov8" title="1">{
        writeContentType(w, jsonContentType)
}</span>

// Render (JsonpJSON) marshals the given interface object and writes it and its callback with custom ContentType.
func (r JsonpJSON) Render(w http.ResponseWriter) (err error) <span class="cov8" title="1">{
        r.WriteContentType(w)
        ret, err := json.Marshal(r.Data)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if r.Callback == "" </span><span class="cov8" title="1">{
                _, err = w.Write(ret)
                return err
        }</span>

        <span class="cov8" title="1">callback := template.JSEscapeString(r.Callback)
        _, err = w.Write([]byte(callback))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">_, err = w.Write([]byte("("))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">_, err = w.Write(ret)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">_, err = w.Write([]byte(")"))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// WriteContentType (JsonpJSON) writes Javascript ContentType.
func (r JsonpJSON) WriteContentType(w http.ResponseWriter) <span class="cov8" title="1">{
        writeContentType(w, jsonpContentType)
}</span>

// Render (AsciiJSON) marshals the given interface object and writes it with custom ContentType.
func (r AsciiJSON) Render(w http.ResponseWriter) (err error) <span class="cov8" title="1">{
        r.WriteContentType(w)
        ret, err := json.Marshal(r.Data)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">var buffer bytes.Buffer
        for _, r := range string(ret) </span><span class="cov8" title="1">{
                cvt := string(r)
                if r &gt;= 128 </span><span class="cov8" title="1">{
                        cvt = fmt.Sprintf("\\u%04x", int64(r))
                }</span>
                <span class="cov8" title="1">buffer.WriteString(cvt)</span>
        }

        <span class="cov8" title="1">_, err = w.Write(buffer.Bytes())
        return err</span>
}

// WriteContentType (AsciiJSON) writes JSON ContentType.
func (r AsciiJSON) WriteContentType(w http.ResponseWriter) <span class="cov8" title="1">{
        writeContentType(w, jsonAsciiContentType)
}</span>

// Render (PureJSON) writes custom ContentType and encodes the given interface object.
func (r PureJSON) Render(w http.ResponseWriter) error <span class="cov8" title="1">{
        r.WriteContentType(w)
        encoder := json.NewEncoder(w)
        encoder.SetEscapeHTML(false)
        return encoder.Encode(r.Data)
}</span>

// WriteContentType (PureJSON) writes custom ContentType.
func (r PureJSON) WriteContentType(w http.ResponseWriter) <span class="cov8" title="1">{
        writeContentType(w, jsonContentType)
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">// Copyright 2017 Manu Martinez-Almeida.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package render

import (
        "net/http"

        "github.com/ugorji/go/codec"
)

// MsgPack contains the given interface object.
type MsgPack struct {
        Data interface{}
}

var msgpackContentType = []string{"application/msgpack; charset=utf-8"}

// WriteContentType (MsgPack) writes MsgPack ContentType.
func (r MsgPack) WriteContentType(w http.ResponseWriter) <span class="cov8" title="1">{
        writeContentType(w, msgpackContentType)
}</span>

// Render (MsgPack) encodes the given interface object and writes data with custom ContentType.
func (r MsgPack) Render(w http.ResponseWriter) error <span class="cov8" title="1">{
        return WriteMsgPack(w, r.Data)
}</span>

// WriteMsgPack writes MsgPack ContentType and encodes the given interface object.
func WriteMsgPack(w http.ResponseWriter, obj interface{}) error <span class="cov8" title="1">{
        writeContentType(w, msgpackContentType)
        var mh codec.MsgpackHandle
        return codec.NewEncoder(w, &amp;mh).Encode(obj)
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">// Copyright 2018 Gin Core Team.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package render

import (
        "net/http"

        "github.com/golang/protobuf/proto"
)

// ProtoBuf contains the given interface object.
type ProtoBuf struct {
        Data interface{}
}

var protobufContentType = []string{"application/x-protobuf"}

// Render (ProtoBuf) marshals the given interface object and writes data with custom ContentType.
func (r ProtoBuf) Render(w http.ResponseWriter) error <span class="cov8" title="1">{
        r.WriteContentType(w)

        bytes, err := proto.Marshal(r.Data.(proto.Message))
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">_, err = w.Write(bytes)
        return err</span>
}

// WriteContentType (ProtoBuf) writes ProtoBuf ContentType.
func (r ProtoBuf) WriteContentType(w http.ResponseWriter) <span class="cov8" title="1">{
        writeContentType(w, protobufContentType)
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">// Copyright 2018 Gin Core Team.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package render

import (
        "io"
        "net/http"
        "strconv"
)

// Reader contains the IO reader and its length, and custom ContentType and other headers.
type Reader struct {
        ContentType   string
        ContentLength int64
        Reader        io.Reader
        Headers       map[string]string
}

// Render (Reader) writes data with custom ContentType and headers.
func (r Reader) Render(w http.ResponseWriter) (err error) <span class="cov8" title="1">{
        r.WriteContentType(w)
        r.Headers["Content-Length"] = strconv.FormatInt(r.ContentLength, 10)
        r.writeHeaders(w, r.Headers)
        _, err = io.Copy(w, r.Reader)
        return
}</span>

// WriteContentType (Reader) writes custom ContentType.
func (r Reader) WriteContentType(w http.ResponseWriter) <span class="cov8" title="1">{
        writeContentType(w, []string{r.ContentType})
}</span>

// writeHeaders writes custom Header.
func (r Reader) writeHeaders(w http.ResponseWriter, headers map[string]string) <span class="cov8" title="1">{
        header := w.Header()
        for k, v := range headers </span><span class="cov8" title="1">{
                if header.Get(k) == "" </span><span class="cov8" title="1">{
                        header.Set(k, v)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file42" style="display: none">// Copyright 2014 Manu Martinez-Almeida.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package render

import (
        "fmt"
        "net/http"
)

// Redirect contains the http request reference and redirects status code and location.
type Redirect struct {
        Code     int
        Request  *http.Request
        Location string
}

// Render (Redirect) redirects the http request to new location and writes redirect response.
func (r Redirect) Render(w http.ResponseWriter) error <span class="cov8" title="1">{
        if (r.Code &lt; http.StatusMultipleChoices || r.Code &gt; http.StatusPermanentRedirect) &amp;&amp; r.Code != http.StatusCreated </span><span class="cov8" title="1">{
                panic(fmt.Sprintf("Cannot redirect with status code %d", r.Code))</span>
        }
        <span class="cov8" title="1">http.Redirect(w, r.Request, r.Location, r.Code)
        return nil</span>
}

// WriteContentType (Redirect) don't write any ContentType.
func (r Redirect) WriteContentType(http.ResponseWriter) {<span class="cov8" title="1">}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">// Copyright 2014 Manu Martinez-Almeida.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package render

import "net/http"

// Render interface is to be implemented by JSON, XML, HTML, YAML and so on.
type Render interface {
        // Render writes data with custom ContentType.
        Render(http.ResponseWriter) error
        // WriteContentType writes custom ContentType.
        WriteContentType(w http.ResponseWriter)
}

var (
        _ Render     = JSON{}
        _ Render     = IndentedJSON{}
        _ Render     = SecureJSON{}
        _ Render     = JsonpJSON{}
        _ Render     = XML{}
        _ Render     = String{}
        _ Render     = Redirect{}
        _ Render     = Data{}
        _ Render     = HTML{}
        _ HTMLRender = HTMLDebug{}
        _ HTMLRender = HTMLProduction{}
        _ Render     = YAML{}
        _ Render     = MsgPack{}
        _ Render     = Reader{}
        _ Render     = AsciiJSON{}
        _ Render     = ProtoBuf{}
)

func writeContentType(w http.ResponseWriter, value []string) <span class="cov8" title="1">{
        header := w.Header()
        if val := header["Content-Type"]; len(val) == 0 </span><span class="cov8" title="1">{
                header["Content-Type"] = value
        }</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">// Copyright 2014 Manu Martinez-Almeida.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package render

import (
        "fmt"
        "io"
        "net/http"
)

// String contains the given interface object slice and its format.
type String struct {
        Format string
        Data   []interface{}
}

var plainContentType = []string{"text/plain; charset=utf-8"}

// Render (String) writes data with custom ContentType.
func (r String) Render(w http.ResponseWriter) error <span class="cov8" title="1">{
        return WriteString(w, r.Format, r.Data)
}</span>

// WriteContentType (String) writes Plain ContentType.
func (r String) WriteContentType(w http.ResponseWriter) <span class="cov8" title="1">{
        writeContentType(w, plainContentType)
}</span>

// WriteString writes data according to its format and write custom ContentType.
func WriteString(w http.ResponseWriter, format string, data []interface{}) (err error) <span class="cov8" title="1">{
        writeContentType(w, plainContentType)
        if len(data) &gt; 0 </span><span class="cov8" title="1">{
                _, err = fmt.Fprintf(w, format, data...)
                return
        }</span>
        <span class="cov8" title="1">_, err = io.WriteString(w, format)
        return</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">// Copyright 2014 Manu Martinez-Almeida.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package render

import (
        "encoding/xml"
        "net/http"
)

// XML contains the given interface object.
type XML struct {
        Data interface{}
}

var xmlContentType = []string{"application/xml; charset=utf-8"}

// Render (XML) encodes the given interface object and writes data with custom ContentType.
func (r XML) Render(w http.ResponseWriter) error <span class="cov8" title="1">{
        r.WriteContentType(w)
        return xml.NewEncoder(w).Encode(r.Data)
}</span>

// WriteContentType (XML) writes XML ContentType for response.
func (r XML) WriteContentType(w http.ResponseWriter) <span class="cov8" title="1">{
        writeContentType(w, xmlContentType)
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">// Copyright 2014 Manu Martinez-Almeida.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package render

import (
        "net/http"

        "gopkg.in/yaml.v2"
)

// YAML contains the given interface object.
type YAML struct {
        Data interface{}
}

var yamlContentType = []string{"application/x-yaml; charset=utf-8"}

// Render (YAML) marshals the given interface object and writes data with custom ContentType.
func (r YAML) Render(w http.ResponseWriter) error <span class="cov8" title="1">{
        r.WriteContentType(w)

        bytes, err := yaml.Marshal(r.Data)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">_, err = w.Write(bytes)
        return err</span>
}

// WriteContentType (YAML) writes YAML ContentType for response.
func (r YAML) WriteContentType(w http.ResponseWriter) <span class="cov8" title="1">{
        writeContentType(w, yamlContentType)
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">// Copyright 2014 Manu Martinez-Almeida.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package gin

import (
        "bufio"
        "io"
        "net"
        "net/http"
)

const (
        noWritten     = -1
        defaultStatus = http.StatusOK
)

// ResponseWriter ...
type ResponseWriter interface {
        http.ResponseWriter
        http.Hijacker
        http.Flusher
        http.CloseNotifier

        // Returns the HTTP response status code of the current request.
        Status() int

        // Returns the number of bytes already written into the response http body.
        // See Written()
        Size() int

        // Writes the string into the response body.
        WriteString(string) (int, error)

        // Returns true if the response body was already written.
        Written() bool

        // Forces to write the http header (status code + headers).
        WriteHeaderNow()

        // get the http.Pusher for server push
        Pusher() http.Pusher
}

type responseWriter struct {
        http.ResponseWriter
        size   int
        status int
}

var _ ResponseWriter = &amp;responseWriter{}

func (w *responseWriter) reset(writer http.ResponseWriter) <span class="cov8" title="1">{
        w.ResponseWriter = writer
        w.size = noWritten
        w.status = defaultStatus
}</span>

func (w *responseWriter) WriteHeader(code int) <span class="cov8" title="1">{
        if code &gt; 0 &amp;&amp; w.status != code </span><span class="cov8" title="1">{
                if w.Written() </span><span class="cov8" title="1">{
                        debugPrint("[WARNING] Headers were already written. Wanted to override status code %d with %d", w.status, code)
                }</span>
                <span class="cov8" title="1">w.status = code</span>
        }
}

func (w *responseWriter) WriteHeaderNow() <span class="cov8" title="1">{
        if !w.Written() </span><span class="cov8" title="1">{
                w.size = 0
                w.ResponseWriter.WriteHeader(w.status)
        }</span>
}

func (w *responseWriter) Write(data []byte) (n int, err error) <span class="cov8" title="1">{
        w.WriteHeaderNow()
        n, err = w.ResponseWriter.Write(data)
        w.size += n
        return
}</span>

func (w *responseWriter) WriteString(s string) (n int, err error) <span class="cov8" title="1">{
        w.WriteHeaderNow()
        n, err = io.WriteString(w.ResponseWriter, s)
        w.size += n
        return
}</span>

func (w *responseWriter) Status() int <span class="cov8" title="1">{
        return w.status
}</span>

func (w *responseWriter) Size() int <span class="cov8" title="1">{
        return w.size
}</span>

func (w *responseWriter) Written() bool <span class="cov8" title="1">{
        return w.size != noWritten
}</span>

// Hijack implements the http.Hijacker interface.
func (w *responseWriter) Hijack() (net.Conn, *bufio.ReadWriter, error) <span class="cov8" title="1">{
        if w.size &lt; 0 </span><span class="cov8" title="1">{
                w.size = 0
        }</span>
        <span class="cov8" title="1">return w.ResponseWriter.(http.Hijacker).Hijack()</span>
}

// CloseNotify implements the http.CloseNotify interface.
func (w *responseWriter) CloseNotify() &lt;-chan bool <span class="cov8" title="1">{
        return w.ResponseWriter.(http.CloseNotifier).CloseNotify()
}</span>

// Flush implements the http.Flush interface.
func (w *responseWriter) Flush() <span class="cov8" title="1">{
        w.WriteHeaderNow()
        w.ResponseWriter.(http.Flusher).Flush()
}</span>

func (w *responseWriter) Pusher() (pusher http.Pusher) <span class="cov8" title="1">{
        if pusher, ok := w.ResponseWriter.(http.Pusher); ok </span><span class="cov0" title="0">{
                return pusher
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">// Copyright 2014 Manu Martinez-Almeida.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package gin

import (
        "net/http"
        "path"
        "regexp"
        "strings"
)

// IRouter defines all router handle interface includes single and group router.
type IRouter interface {
        IRoutes
        Group(string, ...HandlerFunc) *RouterGroup
}

// IRoutes defines all router handle interface.
type IRoutes interface {
        Use(...HandlerFunc) IRoutes

        Handle(string, string, ...HandlerFunc) IRoutes
        Any(string, ...HandlerFunc) IRoutes
        GET(string, ...HandlerFunc) IRoutes
        POST(string, ...HandlerFunc) IRoutes
        DELETE(string, ...HandlerFunc) IRoutes
        PATCH(string, ...HandlerFunc) IRoutes
        PUT(string, ...HandlerFunc) IRoutes
        OPTIONS(string, ...HandlerFunc) IRoutes
        HEAD(string, ...HandlerFunc) IRoutes

        StaticFile(string, string) IRoutes
        Static(string, string) IRoutes
        StaticFS(string, http.FileSystem) IRoutes
}

// RouterGroup is used internally to configure router, a RouterGroup is associated with
// a prefix and an array of handlers (middleware).
type RouterGroup struct {
        Handlers HandlersChain
        basePath string
        engine   *Engine
        root     bool
}

var _ IRouter = &amp;RouterGroup{}

// Use adds middleware to the group, see example code in GitHub.
func (group *RouterGroup) Use(middleware ...HandlerFunc) IRoutes <span class="cov8" title="1">{
        group.Handlers = append(group.Handlers, middleware...)
        return group.returnObj()
}</span>

// Group creates a new router group. You should add all the routes that have common middlewares or the same path prefix.
// For example, all the routes that use a common middleware for authorization could be grouped.
func (group *RouterGroup) Group(relativePath string, handlers ...HandlerFunc) *RouterGroup <span class="cov8" title="1">{
        return &amp;RouterGroup{
                Handlers: group.combineHandlers(handlers),
                basePath: group.calculateAbsolutePath(relativePath),
                engine:   group.engine,
        }
}</span>

// BasePath returns the base path of router group.
// For example, if v := router.Group("/rest/n/v1/api"), v.BasePath() is "/rest/n/v1/api".
func (group *RouterGroup) BasePath() string <span class="cov8" title="1">{
        return group.basePath
}</span>

func (group *RouterGroup) handle(httpMethod, relativePath string, handlers HandlersChain) IRoutes <span class="cov8" title="1">{
        absolutePath := group.calculateAbsolutePath(relativePath)
        handlers = group.combineHandlers(handlers)
        group.engine.addRoute(httpMethod, absolutePath, handlers)
        return group.returnObj()
}</span>

// Handle registers a new request handle and middleware with the given path and method.
// The last handler should be the real handler, the other ones should be middleware that can and should be shared among different routes.
// See the example code in GitHub.
//
// For GET, POST, PUT, PATCH and DELETE requests the respective shortcut
// functions can be used.
//
// This function is intended for bulk loading and to allow the usage of less
// frequently used, non-standardized or custom methods (e.g. for internal
// communication with a proxy).
func (group *RouterGroup) Handle(httpMethod, relativePath string, handlers ...HandlerFunc) IRoutes <span class="cov8" title="1">{
        if matches, err := regexp.MatchString("^[A-Z]+$", httpMethod); !matches || err != nil </span><span class="cov8" title="1">{
                panic("http method " + httpMethod + " is not valid")</span>
        }
        <span class="cov8" title="1">return group.handle(httpMethod, relativePath, handlers)</span>
}

// POST is a shortcut for router.Handle("POST", path, handle).
func (group *RouterGroup) POST(relativePath string, handlers ...HandlerFunc) IRoutes <span class="cov8" title="1">{
        return group.handle("POST", relativePath, handlers)
}</span>

// GET is a shortcut for router.Handle("GET", path, handle).
func (group *RouterGroup) GET(relativePath string, handlers ...HandlerFunc) IRoutes <span class="cov8" title="1">{
        return group.handle("GET", relativePath, handlers)
}</span>

// DELETE is a shortcut for router.Handle("DELETE", path, handle).
func (group *RouterGroup) DELETE(relativePath string, handlers ...HandlerFunc) IRoutes <span class="cov8" title="1">{
        return group.handle("DELETE", relativePath, handlers)
}</span>

// PATCH is a shortcut for router.Handle("PATCH", path, handle).
func (group *RouterGroup) PATCH(relativePath string, handlers ...HandlerFunc) IRoutes <span class="cov8" title="1">{
        return group.handle("PATCH", relativePath, handlers)
}</span>

// PUT is a shortcut for router.Handle("PUT", path, handle).
func (group *RouterGroup) PUT(relativePath string, handlers ...HandlerFunc) IRoutes <span class="cov8" title="1">{
        return group.handle("PUT", relativePath, handlers)
}</span>

// OPTIONS is a shortcut for router.Handle("OPTIONS", path, handle).
func (group *RouterGroup) OPTIONS(relativePath string, handlers ...HandlerFunc) IRoutes <span class="cov8" title="1">{
        return group.handle("OPTIONS", relativePath, handlers)
}</span>

// HEAD is a shortcut for router.Handle("HEAD", path, handle).
func (group *RouterGroup) HEAD(relativePath string, handlers ...HandlerFunc) IRoutes <span class="cov8" title="1">{
        return group.handle("HEAD", relativePath, handlers)
}</span>

// Any registers a route that matches all the HTTP methods.
// GET, POST, PUT, PATCH, HEAD, OPTIONS, DELETE, CONNECT, TRACE.
func (group *RouterGroup) Any(relativePath string, handlers ...HandlerFunc) IRoutes <span class="cov8" title="1">{
        group.handle("GET", relativePath, handlers)
        group.handle("POST", relativePath, handlers)
        group.handle("PUT", relativePath, handlers)
        group.handle("PATCH", relativePath, handlers)
        group.handle("HEAD", relativePath, handlers)
        group.handle("OPTIONS", relativePath, handlers)
        group.handle("DELETE", relativePath, handlers)
        group.handle("CONNECT", relativePath, handlers)
        group.handle("TRACE", relativePath, handlers)
        return group.returnObj()
}</span>

// StaticFile registers a single route in order to serve a single file of the local filesystem.
// router.StaticFile("favicon.ico", "./resources/favicon.ico")
func (group *RouterGroup) StaticFile(relativePath, filepath string) IRoutes <span class="cov8" title="1">{
        if strings.Contains(relativePath, ":") || strings.Contains(relativePath, "*") </span><span class="cov8" title="1">{
                panic("URL parameters can not be used when serving a static file")</span>
        }
        <span class="cov8" title="1">handler := func(c *Context) </span><span class="cov8" title="1">{
                c.File(filepath)
        }</span>
        <span class="cov8" title="1">group.GET(relativePath, handler)
        group.HEAD(relativePath, handler)
        return group.returnObj()</span>
}

// Static serves files from the given file system root.
// Internally a http.FileServer is used, therefore http.NotFound is used instead
// of the Router's NotFound handler.
// To use the operating system's file system implementation,
// use :
//     router.Static("/static", "/var/www")
func (group *RouterGroup) Static(relativePath, root string) IRoutes <span class="cov8" title="1">{
        return group.StaticFS(relativePath, Dir(root, false))
}</span>

// StaticFS works just like `Static()` but a custom `http.FileSystem` can be used instead.
// Gin by default user: gin.Dir()
func (group *RouterGroup) StaticFS(relativePath string, fs http.FileSystem) IRoutes <span class="cov8" title="1">{
        if strings.Contains(relativePath, ":") || strings.Contains(relativePath, "*") </span><span class="cov8" title="1">{
                panic("URL parameters can not be used when serving a static folder")</span>
        }
        <span class="cov8" title="1">handler := group.createStaticHandler(relativePath, fs)
        urlPattern := path.Join(relativePath, "/*filepath")

        // Register GET and HEAD handlers
        group.GET(urlPattern, handler)
        group.HEAD(urlPattern, handler)
        return group.returnObj()</span>
}

func (group *RouterGroup) createStaticHandler(relativePath string, fs http.FileSystem) HandlerFunc <span class="cov8" title="1">{
        absolutePath := group.calculateAbsolutePath(relativePath)
        fileServer := http.StripPrefix(absolutePath, http.FileServer(fs))

        return func(c *Context) </span><span class="cov8" title="1">{
                if _, nolisting := fs.(*onlyfilesFS); nolisting </span><span class="cov8" title="1">{
                        c.Writer.WriteHeader(http.StatusNotFound)
                }</span>

                <span class="cov8" title="1">file := c.Param("filepath")
                // Check if file exists and/or if we have permission to access it
                if _, err := fs.Open(file); err != nil </span><span class="cov8" title="1">{
                        c.Writer.WriteHeader(http.StatusNotFound)
                        c.handlers = group.engine.noRoute
                        // Reset index
                        c.index = -1
                        return
                }</span>

                <span class="cov8" title="1">fileServer.ServeHTTP(c.Writer, c.Request)</span>
        }
}

func (group *RouterGroup) combineHandlers(handlers HandlersChain) HandlersChain <span class="cov8" title="1">{
        finalSize := len(group.Handlers) + len(handlers)
        if finalSize &gt;= int(abortIndex) </span><span class="cov8" title="1">{
                panic("too many handlers")</span>
        }
        <span class="cov8" title="1">mergedHandlers := make(HandlersChain, finalSize)
        copy(mergedHandlers, group.Handlers)
        copy(mergedHandlers[len(group.Handlers):], handlers)
        return mergedHandlers</span>
}

func (group *RouterGroup) calculateAbsolutePath(relativePath string) string <span class="cov8" title="1">{
        return joinPaths(group.basePath, relativePath)
}</span>

func (group *RouterGroup) returnObj() IRoutes <span class="cov8" title="1">{
        if group.root </span><span class="cov8" title="1">{
                return group.engine
        }</span>
        <span class="cov8" title="1">return group</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">// Copyright 2017 Manu Martinez-Almeida.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package gin

import "net/http"

// CreateTestContext returns a fresh engine and context for testing purposes
func CreateTestContext(w http.ResponseWriter) (c *Context, r *Engine) <span class="cov8" title="1">{
        r = New()
        c = r.allocateContext()
        c.reset()
        c.writermem.reset(w)
        return
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">// Copyright 2013 Julien Schmidt. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be found
// at https://github.com/julienschmidt/httprouter/blob/master/LICENSE

package gin

import (
        "net/url"
        "strings"
        "unicode"
)

// Param is a single URL parameter, consisting of a key and a value.
type Param struct {
        Key   string
        Value string
}

// Params is a Param-slice, as returned by the router.
// The slice is ordered, the first URL parameter is also the first slice value.
// It is therefore safe to read values by the index.
type Params []Param

// Get returns the value of the first Param which key matches the given name.
// If no matching Param is found, an empty string is returned.
func (ps Params) Get(name string) (string, bool) <span class="cov8" title="1">{
        for _, entry := range ps </span><span class="cov8" title="1">{
                if entry.Key == name </span><span class="cov8" title="1">{
                        return entry.Value, true
                }</span>
        }
        <span class="cov8" title="1">return "", false</span>
}

// ByName returns the value of the first Param which key matches the given name.
// If no matching Param is found, an empty string is returned.
func (ps Params) ByName(name string) (va string) <span class="cov8" title="1">{
        va, _ = ps.Get(name)
        return
}</span>

type methodTree struct {
        method string
        root   *node
}

type methodTrees []methodTree

func (trees methodTrees) get(method string) *node <span class="cov8" title="1">{
        for _, tree := range trees </span><span class="cov8" title="1">{
                if tree.method == method </span><span class="cov8" title="1">{
                        return tree.root
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func min(a, b int) int <span class="cov8" title="1">{
        if a &lt;= b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}

func countParams(path string) uint8 <span class="cov8" title="1">{
        var n uint
        for i := 0; i &lt; len(path); i++ </span><span class="cov8" title="1">{
                if path[i] != ':' &amp;&amp; path[i] != '*' </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">n++</span>
        }
        <span class="cov8" title="1">if n &gt;= 255 </span><span class="cov8" title="1">{
                return 255
        }</span>
        <span class="cov8" title="1">return uint8(n)</span>
}

type nodeType uint8

const (
        static nodeType = iota // default
        root
        param
        catchAll
)

type node struct {
        path      string
        indices   string
        children  []*node
        handlers  HandlersChain
        priority  uint32
        nType     nodeType
        maxParams uint8
        wildChild bool
}

// increments priority of the given child and reorders if necessary.
func (n *node) incrementChildPrio(pos int) int <span class="cov8" title="1">{
        n.children[pos].priority++
        prio := n.children[pos].priority

        // adjust position (move to front)
        newPos := pos
        for newPos &gt; 0 &amp;&amp; n.children[newPos-1].priority &lt; prio </span><span class="cov8" title="1">{
                // swap node positions
                n.children[newPos-1], n.children[newPos] = n.children[newPos], n.children[newPos-1]

                newPos--
        }</span>

        // build new index char string
        <span class="cov8" title="1">if newPos != pos </span><span class="cov8" title="1">{
                n.indices = n.indices[:newPos] + // unchanged prefix, might be empty
                        n.indices[pos:pos+1] + // the index char we move
                        n.indices[newPos:pos] + n.indices[pos+1:] // rest without char at 'pos'
        }</span>

        <span class="cov8" title="1">return newPos</span>
}

// addRoute adds a node with the given handle to the path.
// Not concurrency-safe!
func (n *node) addRoute(path string, handlers HandlersChain) <span class="cov8" title="1">{
        fullPath := path
        n.priority++
        numParams := countParams(path)

        // non-empty tree
        if len(n.path) &gt; 0 || len(n.children) &gt; 0 </span><span class="cov8" title="1">{
        walk:
                for </span><span class="cov8" title="1">{
                        // Update maxParams of the current node
                        if numParams &gt; n.maxParams </span><span class="cov8" title="1">{
                                n.maxParams = numParams
                        }</span>

                        // Find the longest common prefix.
                        // This also implies that the common prefix contains no ':' or '*'
                        // since the existing key can't contain those chars.
                        <span class="cov8" title="1">i := 0
                        max := min(len(path), len(n.path))
                        for i &lt; max &amp;&amp; path[i] == n.path[i] </span><span class="cov8" title="1">{
                                i++
                        }</span>

                        // Split edge
                        <span class="cov8" title="1">if i &lt; len(n.path) </span><span class="cov8" title="1">{
                                child := node{
                                        path:      n.path[i:],
                                        wildChild: n.wildChild,
                                        indices:   n.indices,
                                        children:  n.children,
                                        handlers:  n.handlers,
                                        priority:  n.priority - 1,
                                }

                                // Update maxParams (max of all children)
                                for i := range child.children </span><span class="cov8" title="1">{
                                        if child.children[i].maxParams &gt; child.maxParams </span><span class="cov8" title="1">{
                                                child.maxParams = child.children[i].maxParams
                                        }</span>
                                }

                                <span class="cov8" title="1">n.children = []*node{&amp;child}
                                // []byte for proper unicode char conversion, see #65
                                n.indices = string([]byte{n.path[i]})
                                n.path = path[:i]
                                n.handlers = nil
                                n.wildChild = false</span>
                        }

                        // Make new node a child of this node
                        <span class="cov8" title="1">if i &lt; len(path) </span><span class="cov8" title="1">{
                                path = path[i:]

                                if n.wildChild </span><span class="cov8" title="1">{
                                        n = n.children[0]
                                        n.priority++

                                        // Update maxParams of the child node
                                        if numParams &gt; n.maxParams </span><span class="cov8" title="1">{
                                                n.maxParams = numParams
                                        }</span>
                                        <span class="cov8" title="1">numParams--

                                        // Check if the wildcard matches
                                        if len(path) &gt;= len(n.path) &amp;&amp; n.path == path[:len(n.path)] </span><span class="cov8" title="1">{
                                                // check for longer wildcard, e.g. :name and :names
                                                if len(n.path) &gt;= len(path) || path[len(n.path)] == '/' </span><span class="cov8" title="1">{
                                                        continue walk</span>
                                                }
                                        }

                                        <span class="cov8" title="1">pathSeg := path
                                        if n.nType != catchAll </span><span class="cov8" title="1">{
                                                pathSeg = strings.SplitN(path, "/", 2)[0]
                                        }</span>
                                        <span class="cov8" title="1">prefix := fullPath[:strings.Index(fullPath, pathSeg)] + n.path
                                        panic("'" + pathSeg +
                                                "' in new path '" + fullPath +
                                                "' conflicts with existing wildcard '" + n.path +
                                                "' in existing prefix '" + prefix +
                                                "'")</span>
                                }

                                <span class="cov8" title="1">c := path[0]

                                // slash after param
                                if n.nType == param &amp;&amp; c == '/' &amp;&amp; len(n.children) == 1 </span><span class="cov8" title="1">{
                                        n = n.children[0]
                                        n.priority++
                                        continue walk</span>
                                }

                                // Check if a child with the next path byte exists
                                <span class="cov8" title="1">for i := 0; i &lt; len(n.indices); i++ </span><span class="cov8" title="1">{
                                        if c == n.indices[i] </span><span class="cov8" title="1">{
                                                i = n.incrementChildPrio(i)
                                                n = n.children[i]
                                                continue walk</span>
                                        }
                                }

                                // Otherwise insert it
                                <span class="cov8" title="1">if c != ':' &amp;&amp; c != '*' </span><span class="cov8" title="1">{
                                        // []byte for proper unicode char conversion, see #65
                                        n.indices += string([]byte{c})
                                        child := &amp;node{
                                                maxParams: numParams,
                                        }
                                        n.children = append(n.children, child)
                                        n.incrementChildPrio(len(n.indices) - 1)
                                        n = child
                                }</span>
                                <span class="cov8" title="1">n.insertChild(numParams, path, fullPath, handlers)
                                return</span>

                        } else<span class="cov8" title="1"> if i == len(path) </span><span class="cov8" title="1">{ // Make node a (in-path) leaf
                                if n.handlers != nil </span><span class="cov8" title="1">{
                                        panic("handlers are already registered for path '" + fullPath + "'")</span>
                                }
                                <span class="cov8" title="1">n.handlers = handlers</span>
                        }
                        <span class="cov8" title="1">return</span>
                }
        } else<span class="cov8" title="1"> { // Empty tree
                n.insertChild(numParams, path, fullPath, handlers)
                n.nType = root
        }</span>
}

func (n *node) insertChild(numParams uint8, path string, fullPath string, handlers HandlersChain) <span class="cov8" title="1">{
        var offset int // already handled bytes of the path

        // find prefix until first wildcard (beginning with ':' or '*')
        for i, max := 0, len(path); numParams &gt; 0; i++ </span><span class="cov8" title="1">{
                c := path[i]
                if c != ':' &amp;&amp; c != '*' </span><span class="cov8" title="1">{
                        continue</span>
                }

                // find wildcard end (either '/' or path end)
                <span class="cov8" title="1">end := i + 1
                for end &lt; max &amp;&amp; path[end] != '/' </span><span class="cov8" title="1">{
                        switch path[end] </span>{
                        // the wildcard name must not contain ':' and '*'
                        case ':', '*':<span class="cov8" title="1">
                                panic("only one wildcard per path segment is allowed, has: '" +
                                        path[i:] + "' in path '" + fullPath + "'")</span>
                        default:<span class="cov8" title="1">
                                end++</span>
                        }
                }

                // check if this Node existing children which would be
                // unreachable if we insert the wildcard here
                <span class="cov8" title="1">if len(n.children) &gt; 0 </span><span class="cov8" title="1">{
                        panic("wildcard route '" + path[i:end] +
                                "' conflicts with existing children in path '" + fullPath + "'")</span>
                }

                // check if the wildcard has a name
                <span class="cov8" title="1">if end-i &lt; 2 </span><span class="cov8" title="1">{
                        panic("wildcards must be named with a non-empty name in path '" + fullPath + "'")</span>
                }

                <span class="cov8" title="1">if c == ':' </span><span class="cov8" title="1">{ // param
                        // split path at the beginning of the wildcard
                        if i &gt; 0 </span><span class="cov8" title="1">{
                                n.path = path[offset:i]
                                offset = i
                        }</span>

                        <span class="cov8" title="1">child := &amp;node{
                                nType:     param,
                                maxParams: numParams,
                        }
                        n.children = []*node{child}
                        n.wildChild = true
                        n = child
                        n.priority++
                        numParams--

                        // if the path doesn't end with the wildcard, then there
                        // will be another non-wildcard subpath starting with '/'
                        if end &lt; max </span><span class="cov8" title="1">{
                                n.path = path[offset:end]
                                offset = end

                                child := &amp;node{
                                        maxParams: numParams,
                                        priority:  1,
                                }
                                n.children = []*node{child}
                                n = child
                        }</span>

                } else<span class="cov8" title="1"> { // catchAll
                        if end != max || numParams &gt; 1 </span><span class="cov8" title="1">{
                                panic("catch-all routes are only allowed at the end of the path in path '" + fullPath + "'")</span>
                        }

                        <span class="cov8" title="1">if len(n.path) &gt; 0 &amp;&amp; n.path[len(n.path)-1] == '/' </span><span class="cov8" title="1">{
                                panic("catch-all conflicts with existing handle for the path segment root in path '" + fullPath + "'")</span>
                        }

                        // currently fixed width 1 for '/'
                        <span class="cov8" title="1">i--
                        if path[i] != '/' </span><span class="cov8" title="1">{
                                panic("no / before catch-all in path '" + fullPath + "'")</span>
                        }

                        <span class="cov8" title="1">n.path = path[offset:i]

                        // first node: catchAll node with empty path
                        child := &amp;node{
                                wildChild: true,
                                nType:     catchAll,
                                maxParams: 1,
                        }
                        n.children = []*node{child}
                        n.indices = string(path[i])
                        n = child
                        n.priority++

                        // second node: node holding the variable
                        child = &amp;node{
                                path:      path[i:],
                                nType:     catchAll,
                                maxParams: 1,
                                handlers:  handlers,
                                priority:  1,
                        }
                        n.children = []*node{child}

                        return</span>
                }
        }

        // insert remaining path part and handle to the leaf
        <span class="cov8" title="1">n.path = path[offset:]
        n.handlers = handlers</span>
}

// getValue returns the handle registered with the given path (key). The values of
// wildcards are saved to a map.
// If no handle can be found, a TSR (trailing slash redirect) recommendation is
// made if a handle exists with an extra (without the) trailing slash for the
// given path.
func (n *node) getValue(path string, po Params, unescape bool) (handlers HandlersChain, p Params, tsr bool) <span class="cov8" title="1">{
        p = po
walk: // Outer loop for walking the tree
        for </span><span class="cov8" title="1">{
                if len(path) &gt; len(n.path) </span><span class="cov8" title="1">{
                        if path[:len(n.path)] == n.path </span><span class="cov8" title="1">{
                                path = path[len(n.path):]
                                // If this node does not have a wildcard (param or catchAll)
                                // child,  we can just look up the next child node and continue
                                // to walk down the tree
                                if !n.wildChild </span><span class="cov8" title="1">{
                                        c := path[0]
                                        for i := 0; i &lt; len(n.indices); i++ </span><span class="cov8" title="1">{
                                                if c == n.indices[i] </span><span class="cov8" title="1">{
                                                        n = n.children[i]
                                                        continue walk</span>
                                                }
                                        }

                                        // Nothing found.
                                        // We can recommend to redirect to the same URL without a
                                        // trailing slash if a leaf exists for that path.
                                        <span class="cov8" title="1">tsr = path == "/" &amp;&amp; n.handlers != nil
                                        return</span>
                                }

                                // handle wildcard child
                                <span class="cov8" title="1">n = n.children[0]
                                switch n.nType </span>{
                                case param:<span class="cov8" title="1">
                                        // find param end (either '/' or path end)
                                        end := 0
                                        for end &lt; len(path) &amp;&amp; path[end] != '/' </span><span class="cov8" title="1">{
                                                end++
                                        }</span>

                                        // save param value
                                        <span class="cov8" title="1">if cap(p) &lt; int(n.maxParams) </span><span class="cov8" title="1">{
                                                p = make(Params, 0, n.maxParams)
                                        }</span>
                                        <span class="cov8" title="1">i := len(p)
                                        p = p[:i+1] // expand slice within preallocated capacity
                                        p[i].Key = n.path[1:]
                                        val := path[:end]
                                        if unescape </span><span class="cov8" title="1">{
                                                var err error
                                                if p[i].Value, err = url.QueryUnescape(val); err != nil </span><span class="cov8" title="1">{
                                                        p[i].Value = val // fallback, in case of error
                                                }</span>
                                        } else<span class="cov8" title="1"> {
                                                p[i].Value = val
                                        }</span>

                                        // we need to go deeper!
                                        <span class="cov8" title="1">if end &lt; len(path) </span><span class="cov8" title="1">{
                                                if len(n.children) &gt; 0 </span><span class="cov8" title="1">{
                                                        path = path[end:]
                                                        n = n.children[0]
                                                        continue walk</span>
                                                }

                                                // ... but we can't
                                                <span class="cov8" title="1">tsr = len(path) == end+1
                                                return</span>
                                        }

                                        <span class="cov8" title="1">if handlers = n.handlers; handlers != nil </span><span class="cov8" title="1">{
                                                return
                                        }</span>
                                        <span class="cov8" title="1">if len(n.children) == 1 </span><span class="cov8" title="1">{
                                                // No handle found. Check if a handle for this path + a
                                                // trailing slash exists for TSR recommendation
                                                n = n.children[0]
                                                tsr = n.path == "/" &amp;&amp; n.handlers != nil
                                        }</span>

                                        <span class="cov8" title="1">return</span>

                                case catchAll:<span class="cov8" title="1">
                                        // save param value
                                        if cap(p) &lt; int(n.maxParams) </span><span class="cov8" title="1">{
                                                p = make(Params, 0, n.maxParams)
                                        }</span>
                                        <span class="cov8" title="1">i := len(p)
                                        p = p[:i+1] // expand slice within preallocated capacity
                                        p[i].Key = n.path[2:]
                                        if unescape </span><span class="cov8" title="1">{
                                                var err error
                                                if p[i].Value, err = url.QueryUnescape(path); err != nil </span><span class="cov8" title="1">{
                                                        p[i].Value = path // fallback, in case of error
                                                }</span>
                                        } else<span class="cov8" title="1"> {
                                                p[i].Value = path
                                        }</span>

                                        <span class="cov8" title="1">handlers = n.handlers
                                        return</span>

                                default:<span class="cov8" title="1">
                                        panic("invalid node type")</span>
                                }
                        }
                } else<span class="cov8" title="1"> if path == n.path </span><span class="cov8" title="1">{
                        // We should have reached the node containing the handle.
                        // Check if this node has a handle registered.
                        if handlers = n.handlers; handlers != nil </span><span class="cov8" title="1">{
                                return
                        }</span>

                        <span class="cov8" title="1">if path == "/" &amp;&amp; n.wildChild &amp;&amp; n.nType != root </span><span class="cov8" title="1">{
                                tsr = true
                                return
                        }</span>

                        // No handle found. Check if a handle for this path + a
                        // trailing slash exists for trailing slash recommendation
                        <span class="cov8" title="1">for i := 0; i &lt; len(n.indices); i++ </span><span class="cov8" title="1">{
                                if n.indices[i] == '/' </span><span class="cov8" title="1">{
                                        n = n.children[i]
                                        tsr = (len(n.path) == 1 &amp;&amp; n.handlers != nil) ||
                                                (n.nType == catchAll &amp;&amp; n.children[0].handlers != nil)
                                        return
                                }</span>
                        }

                        <span class="cov8" title="1">return</span>
                }

                // Nothing found. We can recommend to redirect to the same URL with an
                // extra trailing slash if a leaf exists for that path
                <span class="cov8" title="1">tsr = (path == "/") ||
                        (len(n.path) == len(path)+1 &amp;&amp; n.path[len(path)] == '/' &amp;&amp;
                                path == n.path[:len(n.path)-1] &amp;&amp; n.handlers != nil)
                return</span>
        }
}

// findCaseInsensitivePath makes a case-insensitive lookup of the given path and tries to find a handler.
// It can optionally also fix trailing slashes.
// It returns the case-corrected path and a bool indicating whether the lookup
// was successful.
func (n *node) findCaseInsensitivePath(path string, fixTrailingSlash bool) (ciPath []byte, found bool) <span class="cov8" title="1">{
        ciPath = make([]byte, 0, len(path)+1) // preallocate enough memory

        // Outer loop for walking the tree
        for len(path) &gt;= len(n.path) &amp;&amp; strings.ToLower(path[:len(n.path)]) == strings.ToLower(n.path) </span><span class="cov8" title="1">{
                path = path[len(n.path):]
                ciPath = append(ciPath, n.path...)

                if len(path) &gt; 0 </span><span class="cov8" title="1">{
                        // If this node does not have a wildcard (param or catchAll) child,
                        // we can just look up the next child node and continue to walk down
                        // the tree
                        if !n.wildChild </span><span class="cov8" title="1">{
                                r := unicode.ToLower(rune(path[0]))
                                for i, index := range n.indices </span><span class="cov8" title="1">{
                                        // must use recursive approach since both index and
                                        // ToLower(index) could exist. We must check both.
                                        if r == unicode.ToLower(index) </span><span class="cov8" title="1">{
                                                out, found := n.children[i].findCaseInsensitivePath(path, fixTrailingSlash)
                                                if found </span><span class="cov8" title="1">{
                                                        return append(ciPath, out...), true
                                                }</span>
                                        }
                                }

                                // Nothing found. We can recommend to redirect to the same URL
                                // without a trailing slash if a leaf exists for that path
                                <span class="cov8" title="1">found = fixTrailingSlash &amp;&amp; path == "/" &amp;&amp; n.handlers != nil
                                return</span>
                        }

                        <span class="cov8" title="1">n = n.children[0]
                        switch n.nType </span>{
                        case param:<span class="cov8" title="1">
                                // find param end (either '/' or path end)
                                k := 0
                                for k &lt; len(path) &amp;&amp; path[k] != '/' </span><span class="cov8" title="1">{
                                        k++
                                }</span>

                                // add param value to case insensitive path
                                <span class="cov8" title="1">ciPath = append(ciPath, path[:k]...)

                                // we need to go deeper!
                                if k &lt; len(path) </span><span class="cov8" title="1">{
                                        if len(n.children) &gt; 0 </span><span class="cov8" title="1">{
                                                path = path[k:]
                                                n = n.children[0]
                                                continue</span>
                                        }

                                        // ... but we can't
                                        <span class="cov8" title="1">if fixTrailingSlash &amp;&amp; len(path) == k+1 </span><span class="cov8" title="1">{
                                                return ciPath, true
                                        }</span>
                                        <span class="cov8" title="1">return</span>
                                }

                                <span class="cov8" title="1">if n.handlers != nil </span><span class="cov8" title="1">{
                                        return ciPath, true
                                }</span> else<span class="cov8" title="1"> if fixTrailingSlash &amp;&amp; len(n.children) == 1 </span><span class="cov8" title="1">{
                                        // No handle found. Check if a handle for this path + a
                                        // trailing slash exists
                                        n = n.children[0]
                                        if n.path == "/" &amp;&amp; n.handlers != nil </span><span class="cov8" title="1">{
                                                return append(ciPath, '/'), true
                                        }</span>
                                }
                                <span class="cov8" title="1">return</span>

                        case catchAll:<span class="cov8" title="1">
                                return append(ciPath, path...), true</span>

                        default:<span class="cov8" title="1">
                                panic("invalid node type")</span>
                        }
                } else<span class="cov8" title="1"> {
                        // We should have reached the node containing the handle.
                        // Check if this node has a handle registered.
                        if n.handlers != nil </span><span class="cov8" title="1">{
                                return ciPath, true
                        }</span>

                        // No handle found.
                        // Try to fix the path by adding a trailing slash
                        <span class="cov8" title="1">if fixTrailingSlash </span><span class="cov8" title="1">{
                                for i := 0; i &lt; len(n.indices); i++ </span><span class="cov8" title="1">{
                                        if n.indices[i] == '/' </span><span class="cov8" title="1">{
                                                n = n.children[i]
                                                if (len(n.path) == 1 &amp;&amp; n.handlers != nil) ||
                                                        (n.nType == catchAll &amp;&amp; n.children[0].handlers != nil) </span><span class="cov8" title="1">{
                                                        return append(ciPath, '/'), true
                                                }</span>
                                                <span class="cov8" title="1">return</span>
                                        }
                                }
                        }
                        <span class="cov8" title="1">return</span>
                }
        }

        // Nothing found.
        // Try to fix the path by adding / removing a trailing slash
        <span class="cov8" title="1">if fixTrailingSlash </span><span class="cov8" title="1">{
                if path == "/" </span><span class="cov8" title="1">{
                        return ciPath, true
                }</span>
                <span class="cov8" title="1">if len(path)+1 == len(n.path) &amp;&amp; n.path[len(path)] == '/' &amp;&amp;
                        strings.ToLower(path) == strings.ToLower(n.path[:len(path)]) &amp;&amp;
                        n.handlers != nil </span><span class="cov8" title="1">{
                        return append(ciPath, n.path...), true
                }</span>
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">// Copyright 2014 Manu Martinez-Almeida.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package gin

import (
        "encoding/xml"
        "net/http"
        "os"
        "path"
        "reflect"
        "runtime"
        "strings"
)

// BindKey indicates a default bind key.
const BindKey = "_gin-gonic/gin/bindkey"

// Bind is a helper function for given interface object and returns a Gin middleware.
func Bind(val interface{}) HandlerFunc <span class="cov8" title="1">{
        value := reflect.ValueOf(val)
        if value.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                panic(`Bind struct can not be a pointer. Example:
        Use: gin.Bind(Struct{}) instead of gin.Bind(&amp;Struct{})
`)</span>
        }
        <span class="cov8" title="1">typ := value.Type()

        return func(c *Context) </span><span class="cov8" title="1">{
                obj := reflect.New(typ).Interface()
                if c.Bind(obj) == nil </span><span class="cov8" title="1">{
                        c.Set(BindKey, obj)
                }</span>
        }
}

// WrapF is a helper function for wrapping http.HandlerFunc and returns a Gin middleware.
func WrapF(f http.HandlerFunc) HandlerFunc <span class="cov8" title="1">{
        return func(c *Context) </span><span class="cov8" title="1">{
                f(c.Writer, c.Request)
        }</span>
}

// WrapH is a helper function for wrapping http.Handler and returns a Gin middleware.
func WrapH(h http.Handler) HandlerFunc <span class="cov8" title="1">{
        return func(c *Context) </span><span class="cov8" title="1">{
                h.ServeHTTP(c.Writer, c.Request)
        }</span>
}

// H is a shortcut for map[string]interface{}
type H map[string]interface{}

// MarshalXML allows type H to be used with xml.Marshal.
func (h H) MarshalXML(e *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        start.Name = xml.Name{
                Space: "",
                Local: "map",
        }
        if err := e.EncodeToken(start); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">for key, value := range h </span><span class="cov8" title="1">{
                elem := xml.StartElement{
                        Name: xml.Name{Space: "", Local: key},
                        Attr: []xml.Attr{},
                }
                if err := e.EncodeElement(value, elem); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return e.EncodeToken(xml.EndElement{Name: start.Name})</span>
}

func assert1(guard bool, text string) <span class="cov8" title="1">{
        if !guard </span><span class="cov8" title="1">{
                panic(text)</span>
        }
}

func filterFlags(content string) string <span class="cov8" title="1">{
        for i, char := range content </span><span class="cov8" title="1">{
                if char == ' ' || char == ';' </span><span class="cov8" title="1">{
                        return content[:i]
                }</span>
        }
        <span class="cov8" title="1">return content</span>
}

func chooseData(custom, wildcard interface{}) interface{} <span class="cov8" title="1">{
        if custom == nil </span><span class="cov8" title="1">{
                if wildcard == nil </span><span class="cov8" title="1">{
                        panic("negotiation config is invalid")</span>
                }
                <span class="cov8" title="1">return wildcard</span>
        }
        <span class="cov8" title="1">return custom</span>
}

func parseAccept(acceptHeader string) []string <span class="cov8" title="1">{
        parts := strings.Split(acceptHeader, ",")
        out := make([]string, 0, len(parts))
        for _, part := range parts </span><span class="cov8" title="1">{
                if part = strings.TrimSpace(strings.Split(part, ";")[0]); part != "" </span><span class="cov8" title="1">{
                        out = append(out, part)
                }</span>
        }
        <span class="cov8" title="1">return out</span>
}

func lastChar(str string) uint8 <span class="cov8" title="1">{
        if str == "" </span><span class="cov8" title="1">{
                panic("The length of the string can't be 0")</span>
        }
        <span class="cov8" title="1">return str[len(str)-1]</span>
}

func nameOfFunction(f interface{}) string <span class="cov8" title="1">{
        return runtime.FuncForPC(reflect.ValueOf(f).Pointer()).Name()
}</span>

func joinPaths(absolutePath, relativePath string) string <span class="cov8" title="1">{
        if relativePath == "" </span><span class="cov8" title="1">{
                return absolutePath
        }</span>

        <span class="cov8" title="1">finalPath := path.Join(absolutePath, relativePath)
        appendSlash := lastChar(relativePath) == '/' &amp;&amp; lastChar(finalPath) != '/'
        if appendSlash </span><span class="cov8" title="1">{
                return finalPath + "/"
        }</span>
        <span class="cov8" title="1">return finalPath</span>
}

func resolveAddress(addr []string) string <span class="cov8" title="1">{
        switch len(addr) </span>{
        case 0:<span class="cov8" title="1">
                if port := os.Getenv("PORT"); port != "" </span><span class="cov8" title="1">{
                        debugPrint("Environment variable PORT=\"%s\"", port)
                        return ":" + port
                }</span>
                <span class="cov0" title="0">debugPrint("Environment variable PORT is undefined. Using port :8080 by default")
                return ":8080"</span>
        case 1:<span class="cov8" title="1">
                return addr[0]</span>
        default:<span class="cov8" title="1">
                panic("too much parameters")</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
